<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 24249 -->
<!-- Reviewed: 21584 -->
<sect1 id="zend.db.select">
    <title>Zend_Db_Select</title>

    <sect2 id="zend.db.select.introduction">
        <title>Einführung</title>

        <para>
            Das <classname>Zend_Db_Select</classname>-Objekt repräsentiert ein
            <acronym>SQL</acronym>-<acronym>SELECT</acronym>-Anfrage-Statement. Die Klasse bietet
            Methoden um einzelne Teile der Anfrage hinzuzufügen. Einzelne Teile der Anfrage können
            mit Hilfe von <acronym>PHP</acronym> Methoden und Datenstrukturen angegeben werden, und
            die Klasse erzeugt korrekte <acronym>SQL</acronym>-Syntax. Nachdem die Anfrage
            formuliert wurde, kann sie ausgeführt werden, als wäre sie mit einem normalen String
            geschrieben worden.
        </para>

        <para>
            <classname>Zend_Db_Select</classname> bietet folgenden Nutzen:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    Objektorientierte Methoden um <acronym>SQL</acronym>-Anfragen Stück für Stück
                    zu formulieren.
                </para>
            </listitem>

            <listitem>
                <para>
                    Datenbankunabhängige Abstraktion einiger Teile der
                    <acronym>SQL</acronym>-Anfrage.
                </para>
            </listitem>

            <listitem>
                <para>
                    In den meisten Fällen automatische Quotierung von Metadaten um zu
                    erlauben, dass Bezeichner reservierte <acronym>SQL</acronym>-Wörter und
                    spezielle Zeichen enthalten dürfen.
                </para>
            </listitem>

            <listitem>
                <para>
                    Quotierung von Bezeichnern und Werten, um das Risiko von
                    Angriffen durch <acronym>SQL</acronym>-Injektion zu verringern.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Nutzung von <classname>Zend_Db_Select</classname> ist nicht zwingend erforderlich. Für
            einfache <acronym>SELECT</acronym>-Anfragen ist es normalerweise einfacher, die gesamte
            <acronym>SQL</acronym>-Anfrage in einem String zu formulieren und mit Hilfe der Methoden
            der Adapterklasse, wie <methodname>query()</methodname> oder
            <methodname>fetchAll()</methodname>, auszuführen. Die Nutzung von
            <classname>Zend_Db_Select</classname> ist hilfreich, wenn eine
            <acronym>SELECT</acronym>-Anfrage prozedural oder basierend auf der konditionellen
            Logik der Anwendung zusammengesetzt wird.
        </para>
    </sect2>

    <sect2 id="zend.db.select.creating">
        <title>Erzeugung eines Select-Objekts</title>

        <para>
            Die Instanz eines <classname>Zend_Db_Select</classname>-Objekts kann mit Hilfe der
            Methode <methodname>select()</methodname> des
            <classname>Zend_Db_Adapter_Abstract</classname>-Objekts erzeugt werden.
        </para>

        <example id="zend.db.select.creating.example-db">
            <title>Beispiel für die Nutzung der Methode select() der Datenbankadapterklasse</title>

            <programlisting language="php"><![CDATA[
$db = Zend_Db::factory( ...Optionen... );
$select = $db->select();
]]></programlisting>
        </example>

        <para>
            Ein anderer Weg ein <classname>Zend_Db_Select</classname>-Objekt zu erzeugen, ist die
            Nutzung des Konstruktors unter Angabe des Datenbankadapters als Argument.
        </para>

        <example id="zend.db.select.creating.example-new">
            <title>Beispiel für die Erzeugung eines Select-Objekts</title>

            <programlisting language="php"><![CDATA[
$db = Zend_Db::factory( ...Optionen... );
$select = new Zend_Db_Select($db);
]]></programlisting>
        </example>
    </sect2>

    <sect2 id="zend.db.select.building">
        <title>Erstellung von Select-Anfragen</title>

        <para>
            Wenn die Anfrage erstellt wird, können Bedingungen der Anfrage nacheinander hinzugefügt
            werden. Es gibt separate Methoden für das Hinzufügen von verschiedenen Bedingungen
            zum <classname>Zend_Db_Select</classname>-Objekt.
        </para>

        <example id="zend.db.select.building.example">
            <title>Beispiele für die Nutzung der Methoden zum Hinzufügen von Bedingungen</title>

            <programlisting language="php"><![CDATA[
// Erzeugung des Zend_Db_Select-Objekts
$select = $db->select();

// Hinzufügen einer FROM Bedingung
$select->from( ...Angabe von Tabelle und Spalten... )

// Hinzufügen einer WHERE Bedingung
$select->where( ...Angabe von Suchkriterien... )

// Hinzufügen einer ORDER BY Bedingung
$select->order( ...Angabe von Sortierkriterien... );
]]></programlisting>
        </example>

        <para>
            Die meisten Methoden des <classname>Zend_Db_Select</classname>-Objekts lassen sich auch
            über das bequeme Fluent Interface nutzen. Fluent Interface bedeutet, dass jede Methode
            eine Referenz auf das aufrufende Objekt zurück gibt, daher kann direkt eine andere
            Methode aufgerufen werden.
        </para>

        <example id="zend.db.select.building.example-fluent">
            <title>Beispiel für die Nutzung des Fluent Interface</title>

            <programlisting language="php"><![CDATA[
$select = $db->select()
    ->from( ...Angabe von Tabelle und Spalten... )
    ->where( ...Angabe von Suchkriterien... )
    ->order( ...Angabe von Sortierkriterien... );
]]></programlisting>
        </example>

        <para>
            Die Beispiele in diesem Abschnitt zeigen die Nutzung des Fluent Interface, es kann aber
            auch immer das normale Interface verwendet werden. Häufig ist es nötig das normale
            Interface zu nutzen, zum Beispiel wenn die Anwendung vor dem Hinzufügen der Bedingung
            Berechnungen durchführen muss.
        </para>

        <sect3 id="zend.db.select.building.from">
            <title>Hinzufügen eines FROM Abschnitts</title>

            <para>
                Um die Tabelle für die Anfrage anzugeben, wird die Methode
                <methodname>from()</methodname>
                verwendet. Der Tabellenname kann als einfacher String übergeben werden.
                <classname>Zend_Db_Select</classname> wendet Quotierung auf Bezeichner an, es können
                also auch spezielle Zeichen verwendet werden.
            </para>

            <example id="zend.db.select.building.from.example">
                <title>Beispiel für die Methode from()</title>

                <programlisting language="php"><![CDATA[
// Erstellen dieser Anfrage:
//   SELECT *
//   FROM "products"

$select = $db->select()
             ->from('products');
]]></programlisting>
            </example>

            <para>
                Es kann auch der Beziehungsname (auch Aliasname genannt) einer Tabelle angegeben
                werden. Anstelle eines einfachen Strings muss dann ein assoziatives Array übergeben
                werden, welches den Beziehungsnamen dem tatsächlichen Tabellennamen zuordnet. In
                anderen Bedingungen der <acronym>SQL</acronym>-Anfrage kann dann dieser
                Beziehungsname verwendet werden. Wenn die Anfrage mehr als eine Tabelle verbindet,
                generiert <classname>Zend_Db_Select</classname> eindeutige Beziehungsnamen basierend
                auf den Tabellennamen, wenn keine Beziehungsnamen angegeben wurden.
            </para>

            <example id="zend.db.select.building.from.example-cname">
                <title>Beispiel für das Angeben eines Beziehungsnamens</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p.*
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'));
]]></programlisting>
            </example>

            <para>
                Einige <acronym>RDBMS</acronym>-Marken unterstützen einen voran stehenden
                Schemenbezeichner für eine Tabelle. Der Tabellenname kann mit
                "<command>schemaName.tabellenName</command>" angegeben werden,
                <classname>Zend_Db_Select</classname> quotiert die einzelnen Teile für sich. Der
                Schemaname kann aber auch separat angegeben werden. Ein Schemaname, der mit dem
                Tabellennamen angegeben wurde, bekommt Vorrang, falls beides angegeben wurde.
            </para>

            <example id="zend.db.select.building.from.example-schema">
                <title>Beispiel für das Angeben eines Schemanamens</title>

                <programlisting language="php"><![CDATA[
// Erzeut diese Anfrage:
//   SELECT *
//   FROM "myschema"."products"

$select = $db->select()
             ->from('myschema.products');

// oder

$select = $db->select()
             ->from('products', '*', 'myschema');
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.columns">
            <title>Hinzufügen von Spalten</title>

            <para>
                Im zweiten Argument der Methode <methodname>from()</methodname> kann angegeben
                werden, welche Spalten der Tabelle ausgelesen werden sollen. Werden keine
                Spalten angegeben, so gilt der Standardwert <emphasis>*</emphasis>, der
                <acronym>SQL</acronym> Platzhalter für alle Spalten.
            </para>

            <para>
                Die Spalten können in einem einfachen Array von Strings oder einem assoziativen
                Array, in dem Aliasnamen den Spaltennamen zugewiesen werden, angegeben werden. Soll
                nur eine einzelne Spalte ohne Aliasnamen ausgelesen werden, so kann auch ein
                einfacher String übergeben werden.
            </para>

            <para>
                Wird ein leeres Array übergeben, so werden auch keine Spalten der Tabelle in den
                Ergebnissatz aufgenommen. Ein Codebeispiel gibt es unter
                <link linkend="zend.db.select.building.join.example-no-columns">Codebeispiel</link>
                bei der Methode <methodname>join()</methodname>.
            </para>

            <para>
                Der Spaltenname kann mit "<command>beziehungsName.spaltenName</command>" angegeben
                werden. <classname>Zend_Db_Select</classname> quotiert die einzelnen Teile für sich.
                Wird kein Beziehungsname für die Spalte angegeben, dann wird der Beziehungsname der
                Tabelle der aktuellen Methode <methodname>from()</methodname> verwendet.
            </para>

            <example id="zend.db.select.building.columns.example">
                <title>Beispiele für das Angeben von Spalten</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'));

// Erzeugt dieselbe Anfrage, Angabe von Beziehungsnamen:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('p.product_id', 'p.product_name'));

// Erzeugt diese Anfrage mit einem Alias für eine Spalte:
//   SELECT p."product_id" AS prodno, p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('prodno' => 'product_id', 'product_name'));
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.columns-expr">
            <title>Hinzufügen von Spalten mit Ausdrücke</title>

            <para>
                Spalten in einer <acronym>SQL</acronym>-Anfrage sind manchmal Ausdrücke, keine
                einfachen Spaltennamen einer Tabelle. Ausdrücke dürfen keine Beziehungsnamen oder
                Quotierungen bekommen. Wenn der Spaltenstring runde Klammern enthält, erkennt
                <classname>Zend_Db_Select</classname> dies als Ausdruck.
            </para>

            <para>
                Es kann auch ein Objekt des Typs <classname>Zend_Db_Expr</classname> erzeugt werden
                um zu verhindern, dass ein String wie ein Spaltenname behandelt wird.
                <classname>Zend_Db_Expr</classname> ist eine Minimalklasse, die einen String enthält.
                <classname>Zend_Db_Select</classname> erkennt Objekte des Typs
                <classname>Zend_Db_Expr</classname> und konvertiert diese in Strings, nimmt aber
                keine Änderungen daran vor, wie Quotierung oder Beziehungsnamen.
            </para>

            <note>
                <para>
                    Die Benutzung von <classname>Zend_Db_Expr</classname> für Spaltennamen ist nicht
                    nötig, wenn die Spaltennamen Ausdrücke runde Klammern enthalten.
                    <classname>Zend_Db_Select</classname> erkennt diese und behandelt den String als
                    Ausdruck und lässt Quotierung und Beziehungsnamen aus.
                </para>
            </note>

            <example id="zend.db.select.building.columns-expr.example">
                <title>Beispiel für das Angeben von Spaltennamen, die Ausdrücke enthalten</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", LOWER(product_name)
//   FROM "products" AS p
// Ein Ausdruck eingeschlossen von runden Klammern wird zu Zend_Db_Expr.

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'LOWER(product_name)'));

// Erzeugt diese Anfrage:
//   SELECT p."product_id", (p.cost * 1.08) AS cost_plus_tax
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id',
                          'cost_plus_tax' => '(p.cost * 1.08)'));

// Erzeugt diese Anfrage unter ausdrücklicher Verwendung  von Zend_Db_Expr:
//   SELECT p."product_id", p.cost * 1.08 AS cost_plus_tax
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id',
                          'cost_plus_tax' =>
                              new Zend_Db_Expr('p.cost * 1.08'))
                    );
]]></programlisting>
            </example>

            <para>
                In den oben stehenden Fällen ändert <classname>Zend_Db_Select</classname> den String
                nicht mit Beziehungsnamen oder Bezeichnerquotierung. Wenn diese Änderungen notwendig
                sein sollten um Doppeldeutigkeiten aufzulösen, muss dies manuell am String
                geändert werden.
            </para>

            <para>
                Wenn die Spaltennamen aus <acronym>SQL</acronym>-Schlüsselwörtern bestehen oder
                spezielle Zeichen enthalten, sollte die Methode
                <methodname>quoteIdentifier()</methodname> verwendet werden und der Rückgabewert in
                den String eingefügt werden. Die Methode <methodname>quoteIdentifier()</methodname>
                verwendet <acronym>SQL</acronym>-Quotierung um Bezeichner abzugrenzen, wodurch klar
                wird, dass es sich um einen Bezeichner für eine Tabelle oder Spalte handelt, und
                nicht um einen anderen Teil der <acronym>SQL</acronym>-Syntax.
            </para>

            <para>
                Der Code wird datenbankunabhängiger, wenn die Methode
                <methodname>quoteIdentifier()</methodname> anstelle von direkter Eingabe
                der Quotierungszeichen verwendet wird, da einige <acronym>RDBMS</acronym>-Marken
                nicht-Standard Symbole für die Quotierung von Bezeichnern verwenden. Die
                Methode <methodname>quoteIdentifier()</methodname> wählt die passenden
                Quotierungssymbole für den Adaptertyp aus. Die
                Methode <methodname>quoteIdentifier()</methodname> ersetzt außerdem alle
                Quotierungszeichen innerhalb des Bezeichners.
            </para>

            <example id="zend.db.select.building.columns-quoteid.example">
                <title>Beispiel für die Quotierung von Spalten in einem Ausdruck</title>

                <programlisting language="php"><![CDATA[
// Erzeugt folgende Anfrage und quotiert dabei einen Spaltennamen
// "from" im Ausdruck:
//   SELECT p."from" + 10 AS origin
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('origin' =>
                          '(p.' . $db->quoteIdentifier('from') . ' + 10)')
                   );
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.columns-atomic">
            <title>Spalten zu einer existierenden FROM oder JOIN Tabelle hinzufügen</title>

            <para>
                Es kann Fälle geben, in denen es gewünscht ist, Spalten zu einer bestehenden
                <acronym>FROM</acronym>- oder <acronym>JOIN</acronym>-Tabelle hinzuzufügen, nachdem
                diese Methoden aufgerufen wurden. Die Methode <methodname>columns()</methodname>
                erlaubt es spezifische Spalten an jedem Punkt hinzuzufügen, bevor die Abfrage
                aufgeführt wird. Die Spalte kann entweder als String oder
                <classname>Zend_Db_Expr</classname> oder als Array dieser Elemente angegeben werden.
                Das zweite Argument dieser Methode kann unterdrückt werden, was impliziert, dass die
                Spalten zu der <acronym>FROM</acronym>-Tabelle hinzugefügt werden sollen,
                andernfall muß ein bestehender Korrelationsname verwendet werden.
            </para>

            <example id="zend.db.select.building.columns-atomic.example">
                <title>Beispiel für das Hinzufügen von Spalten mit der Methode columns()</title>

                <programlisting language="php"><![CDATA[
// Diese Abfrage bauen:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'), 'product_id')
             ->columns('product_name');

// Dieselbe Abfrage bauen, durch Angabe der Korrelationsnamen:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'), 'p.product_id')
             ->columns('product_name', 'p');
             // Alternativ kann columns('p.product_name') verwendet werden
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.join">
            <title>Hinzufügen einer weiteren Tabelle zu der Anfrage mit JOIN</title>

            <para>
                Viele nützliche Anfragen benötigen ein <acronym>JOIN</acronym> um mehrere Spalten
                verschiedener Tabellen miteinander zu kombinieren. Tabellen können zu einer
                <classname>Zend_Db_Select</classname>-Anfrage mit der
                Methode <methodname>join()</methodname> hinzugefügt werden. Die Nutzung dieser
                Methode ist ähnlich der Methode <methodname>from()</methodname>, außer dass in den
                meisten Fällen zusätzlich eine Join-Bedingung angegeben werden kann.
            </para>

            <example id="zend.db.select.building.join.example">
                <title>Beispiel für die Methode join()</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", p."product_name", l.*
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id');
]]></programlisting>
            </example>

            <para>
                Das zweite Argument der Methode <methodname>join()</methodname> ist ein String mit
                der Join-Bedingung. Dies ist ein Ausdruck die Kriterien angibt, welche Zeilen
                in der einen Tabelle mit Zeilen einer anderen Tabelle verknüpft werden. Es können
                Beziehungsnamen in diesem Ausdruck verwendet werden.
            </para>

            <note>
               <para>
                    Es wird keine Quotierung auf den Ausdruck für die Join-Bedingung angewendet.
                    Werden Spaltennamen verwendet, welche Quotierung benötigen, so muss
                    <methodname>quoteIdentifier()</methodname> verwendet werden, wenn der String für
                    die Join-Bedingung formuliert wird.
                </para>
            </note>

            <para>
                Das dritte Argument für <methodname>join()</methodname> ist ein Array von
                Spaltennamen, entsprechend des Arrays der Methode <methodname>from()</methodname>.
                Der Standard ist ebenfalls "<emphasis>*</emphasis>" und unterstützt Beziehungsnamen,
                Ausdrücke und <classname>Zend_Db_Expr</classname> in der gleichen Weise wie dem
                Array von Spaltennamen der Methode <methodname>from()</methodname>.
            </para>

            <para>
                Wenn keine Spalten einer Tabelle ausgewählt werden soll, muss ein leeres Array für
                die Liste der Spaltennamen übergeben werden. Diese Nutzung funktioniert ebenfalls
                in der Methode <methodname>from()</methodname>, aber normalerweise werden einige
                Spalten der primären Tabelle in den Anfragen benötigt, während möglicherweise keine
                Spalten der verbundenen Tabelle ausgewählt werden sollen.
            </para>

            <example id="zend.db.select.building.join.example-no-columns">
                <title>Beispiel für das Angeben keiner Spalten</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array() ); // leere Liste von Spalten
]]></programlisting>

                <para>
                    Zu beachten ist, dass leere <methodname>array()</methodname> in dem oben
                    stehenden Beispiel, an der Stelle einer Liste von Spalten der verbundenen
                    Tabelle.
                </para>
            </example>

            <para>
                <acronym>SQL</acronym> kennt verschiedene Varianten von Joins. In der Liste weiter
                unten sind Methoden für die verschiedenen Join-Varianten zu finden, die
                <classname>Zend_Db_Select</classname> unterstützt.
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <command>INNER JOIN</command> mit den Methoden
                        <methodname>join(tabelle, join, [spalten])</methodname> oder
                        <methodname>joinInner(tabelle, join, [spalten])</methodname>.
                    </para>

                    <para>
                        Dies wird der gebräuchlichste Typ von Join sein. Zeilen jeder Tabelle
                        werden mit Hilfe der angegebenen Join-Bedingung verglichen. Der
                        Ergebnissatz enthält nur die Zeilen, die der Join Bedingungen entsprechen.
                        Der Ergebnissatz kann leer sein, wenn keine Zeile die Bedingung erfüllt.
                    </para>

                    <para>
                        Alle <acronym>RDBMS</acronym>-Marken unterstützen diese Variante.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>LEFT JOIN</command> mit der Methode
                        <methodname>joinLeft(tabelle, bedingung, [spalten])</methodname>.
                    </para>

                    <para>
                        Alle Zeilen der links vom Operanden stehenden Tabelle sind enthalten,
                        passende Zeilen der rechts stehenden Tabelle sind ebenfalls enthalten. Die
                        Spalten der rechts stehenden Tabelle werden mit <constant>NULL</constant>
                        aufgefüllt, wenn keine zu der linken Tabelle passenden Zeilen existieren.
                    </para>

                    <para>
                        Alle <acronym>RDBMS</acronym>-Marken unterstützen diese Variante.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>RIGHT JOIN</command> mit der Methode
                        <methodname>joinRight(tabelle, bedingung, [spalten])</methodname>.
                    </para>

                    <para>
                        Right Outer Join ist das Gegenstück zu Left Outer Join. Alle Zeilen der
                        rechts vom Operanden stehenden Tabelle sind enthalten, passende Zeilen der
                        links stehenden Tabelle sind ebenfalls enthalten. Die Spalten der links
                        stehenden Tabelle werden mit <constant>NULL</constant> aufgefüllt, wenn
                        keine zu der rechten Tabelle passenden Zeilen existieren.
                    </para>

                    <para>
                        Einige <acronym>RDBMS</acronym>-Marken unterstützen diesen Join nicht,
                        aber grundsätzlich kann jeder Right Join durch einen Left Join mit
                        umgekehrter Sortierung der Tabellen dargestellt werden.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>FULL JOIN</command> mit der Methode
                        <methodname>joinFull(tabelle, bedingung, [spalten])</methodname>.
                    </para>

                    <para>
                        Ein Full Outer Join ist wie eine Kombination eines Left Outer Join mit
                        einem Right Outer Join. Alle Zeilen beider Tabellen sind enthalten, gepaart
                        miteinander in der gleichen Zeile des Ergebnissatzes wenn die
                        Join-Bedingung erfüllt wird, oder wenn nicht, mit <constant>NULL</constant>
                        an Stelle der Spalten der anderen Tabelle.
                    </para>

                    <para>
                        Einige <acronym>RDBMS</acronym>-Marken unterstützen diesen Join nicht.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>CROSS JOIN</command> mit der Methode
                        <methodname>joinCross(tabelle, [spalten])</methodname>.
                    </para>

                    <para>
                        Ein Cross Join ist ein Kartesisches Produkt. Jede Zeile der ersten Tabelle
                        wird mit jeder Zeile der zweiten Tabelle verbunden. Daher ist die Anzahl
                        der Zeilen im Ergebnissatz gleich dem Produkt der Zeilenanzahlen der beiden
                        Tabellen. Der Ergebnissatz kann mit Bedingungen einer
                        <acronym>WHERE</acronym>-Bedingung gefiltert werden. Ein Cross Join ist
                        ähnlich der alten <acronym>SQL</acronym>-89 Join Syntax.
                    </para>

                    <para>
                        Die Methode <methodname>joinCross()</methodname> hat keinen Parameter für
                        die Join-Bedingung. Einige <acronym>RDBMS</acronym>-Marken unterstützen
                        diesen Join nicht.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>NATURAL JOIN</command> mit der Methode
                        <methodname>joinNatural(tabelle, [spalten])</methodname>.
                    </para>

                    <para>
                        Ein Natural Join vergleicht alle Spalten die in beiden Tabellen mit
                        gleichem Namen vorkommen. Der Vergleich prüft Gleichheit aller Spalten, ein
                        Vergleich auf Ungleichheit ist kein Natural Join. Von dieser
                        <acronym>API</acronym> werden nur Natural Inner Joins unterstützt, auch wenn
                        <acronym>SQL</acronym> auch Natural Outer Joins erlaubt.
                    </para>

                    <para>
                        Die Methode <methodname>joinNatural()</methodname> hat keinen Parameter für
                        die Join-Bedingung.
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                Zusätzlich zu diesen Join-Methoden können Abfragen durch Verwendung der Methoden
                JoinUsing vereinfacht werden. Statt dass eine komplette Definition des Joins
                angegeben wird, kann einfach der Spaltenname übergeben werden, auf welchem gejoint
                werden soll und das <classname>Zend_Db_Select</classname>-Objekt vervollständigt die
                Bedingung alleine.
            </para>

            <example id="zend.db.select.building.joinusing.example">
                <title>Beispiel für die Methode joinUsing()</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Abfrage
//   SELECT *
//   FROM "table1"
//   JOIN "table2"
//   ON "table1".column1 = "table2".column1
//   WHERE column2 = 'foo'

$select = $db->select()
             ->from('table1')
             ->joinUsing('table2', 'column1')
             ->where('column2 = ?', 'foo');
]]></programlisting>
            </example>

            <para>
                Jede der anwendbaren Join-Methoden in der Komponente
                <classname>Zend_Db_Select</classname> hat eine entsprechende 'using'-Methode.
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <methodname>joinUsing(table, join, [columns])</methodname> und
                        <methodname>joinInnerUsing(table, join, [columns])</methodname>
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <methodname>joinLeftUsing(table, join, [columns])</methodname>
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <methodname>joinRightUsing(table, join, [columns])</methodname>
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <methodname>joinFullUsing(table, join, [columns])</methodname>
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.db.select.building.where">
            <title>Hinzufügen eines WHERE-Abschnitts</title>

            <para>
                Mit der Methode <methodname>where()</methodname> können Kriterien angegeben werden,
                die den Ergebnissatz einschränken. Das erste Argument
                dieser Methode ist ein <acronym>SQL</acronym>-Ausdruck, welche in einer
                <acronym>SQL</acronym>-<acronym>WHERE</acronym>-Klausel der Anfrage steht.
            </para>

            <example id="zend.db.select.building.where.example">
                <title>Beispiel für die Methode where()</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE price > 100.00

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price > 100.00');
]]></programlisting>
            </example>

            <note>
                <para>
                    Auf Ausdrücke, welche an die Methoden <methodname>where()</methodname> oder
                    <methodname>orWhere()</methodname> übergeben werden, wird keine
                    Quotierung angewendet. Werden Spaltennamen verwendet, die quotiert werden
                    müssen, so muss <methodname>quoteIdentifier()</methodname> verwendet werden,
                    wenn der String für die Bedingung formuliert wird.
                </para>
            </note>

            <para>
                Das zweite Argument der Methode <methodname>where()</methodname> ist optional. Es
                ist ein Wert, der in den Ausdruck eingesetzt wird.
                <classname>Zend_Db_Select</classname> quotiert den Wert und ersetzt ihn für ein
                Fragezeichen ("<emphasis>?</emphasis>") im Ausdruck.
            </para>

            <example id="zend.db.select.building.where.example-param">
                <title>Beispiel für einen Parameter in der Methode where()</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price > 100.00)

$minimumPrice = 100;

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price > ?', $minimumPrice);
]]></programlisting>
            </example>

            <para>
                Man kann als zweiten Parameter ein Array an die Methode
                <methodname>where()</methodname> übergeben, wenn der <acronym>SQL</acronym>-Operator
                IN verwendet wird.
            </para>

            <example id="zend.db.select.building.where.example-array">
                <title>Beispiel mit Array als Parameters in der Methode where()</title>

                <programlisting language="php"><![CDATA[
// Diese Abrage wird gebaut:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (product_id IN (1, 2, 3))

$productIds = array(1, 2, 3);

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('product_id IN (?)', $productIds);
]]></programlisting>
            </example>

            <para>
                Die Methode <methodname>where()</methodname> kann mehrere Male in demselben
                <classname>Zend_Db_Select</classname>-Objekt aufgerufen werden. Die daraus folgende
                Anfrage kombiniert die unterschiedlichen Ausdrücke unter Benutzung von
                <acronym>AND</acronym> dazwischen.
            </para>

            <example id="zend.db.select.building.where.example-and">
                <title>Beispiel für Mehrfachaufruf der Methode where()</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price > 100.00)
//     AND (price < 500.00)

$minimumPrice = 100;
$maximumPrice = 500;

$select = $db->select()
            ->from('products',
                   array('product_id', 'product_name', 'price'))
            ->where('price > ?', $minimumPrice)
            ->where('price < ?', $maximumPrice);
]]></programlisting>
            </example>

            <para>
                Wenn mehrere Ausdrücke mit <acronym>OR</acronym> verknüpft werden sollen, kann die
                Methode <methodname>orWhere()</methodname> verwendet werden. Sie wird genauso
                benutzt wie die Methode <methodname>where()</methodname>, außer dass dem angegebenen
                Ausdruck ein <acronym>OR</acronym> vorangestellt wird, anstelle eines
                <acronym>AND</acronym>.
            </para>

            <example id="zend.db.select.building.where.example-or">
                <title>Beispiel für die Methode orWhere()</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price < 100.00)
//     OR (price > 500.00)

$minimumPrice = 100;
$maximumPrice = 500;

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price < ?', $minimumPrice)
             ->orWhere('price > ?', $maximumPrice);
]]></programlisting>
            </example>

            <para>
                <classname>Zend_Db_Select</classname> klammert Ausdrücke automatisch mit runden
                Klammern ein, wenn sie mit einer der Methoden <methodname>where()</methodname> oder
                <methodname>orWhere()</methodname> erzeugt wurden. Dies hilft sicherzustellen,
                dass das Voranstellen von Boolschen Operatoren keine unerwarteten Ergebnisse
                nach sich zieht.
            </para>

            <example id="zend.db.select.building.where.example-parens">
                <title>Beispiel für das Einklammern von Boolschen Ausdrücken</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price < 100.00 OR price > 500.00)
//     AND (product_name = 'Apple')

$minimumPrice = 100;
$maximumPrice = 500;
$prod = 'Apple';

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where("price < $minimumPrice OR price > $maximumPrice")
             ->where('product_name = ?', $prod);
]]></programlisting>
            </example>

            <para>
                Im oben stehenden Beispiel wären die Ergebnisse ohne die Klammern ziemlich
                anders, weil <acronym>AND</acronym> eine höhere Priorität als <acronym>OR</acronym>
                hat. <classname>Zend_Db_Select</classname> erzeugt runde Klammern, wodurch jeder
                Ausdruck von aufeinander folgenden Aufrufen der Methode
                <methodname>where()</methodname> fester binden als das <acronym>AND</acronym>,
                welches die Ausdrücke kombiniert.
            </para>
        </sect3>

        <sect3 id="zend.db.select.building.group">
            <title>Hinzufügen eines GROUP BY-Abschnitts</title>

            <para>
                In <acronym>SQL</acronym> ermöglicht der <command>GROUP BY</command>-Abschnitt die
                Zeilenzahl des Ergebnissatzes auf eine Zeile pro eindeutigem Wert der Spalte(n)
                einzuschränken, welche im <command>GROUP BY</command>-Abschnitt benannt sind.
            </para>

            <para>
                In <classname>Zend_Db_Select</classname> können diese Spalte(n) mit der
                Methode <methodname>group()</methodname> angegeben werden. Das Argument der Methode
                ist ein Spaltenname oder ein Array von Spaltennamen, welche im
                <command>GROUP BY</command>-Abschnitt stehen sollen.
            </para>

            <example id="zend.db.select.building.group.example">
                <title>Beispiel für die Methode group()</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", COUNT(*) AS line_items_per_product
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array('line_items_per_product' => 'COUNT(*)'))
             ->group('p.product_id');
]]></programlisting>
            </example>

            <para>
                Wie in dem Array von Spaltennamen der Methode <methodname>from()</methodname>, so
                können auch hier Beziehungsnamen in den Strings der Spaltennamen verwendet werden,
                und der Spaltenname wird als Bezeichner quotiert, wenn er nicht in runden Klammern
                steht oder ein Objekt des Typs <classname>Zend_Db_Expr</classname> ist.
            </para>
        </sect3>

        <sect3 id="zend.db.select.building.having">
            <title>Hinzufügen eines HAVING-Abschnittes</title>

            <para>
                In <acronym>SQL</acronym> fügt der <constant>HAVING</constant>-Abschnitt eine
                Beschränkungsbedingung für Gruppen von Zeilen ein. Dies ist ähnlich der
                Einschränkungsbedingungen auf Zeilen, des <constant>WHERE</constant>-Abschnittes.
                Die beiden Abschnitte unterscheiden sich jedoch, denn die <constant>WHERE</constant>
                Bedingungen werden angewendet, bevor Gruppen definiert wurden. Im Gegensatz werden
                <constant>HAVING</constant>-Bedingungen erst angewendet, nachdem Gruppen definiert
                wurden.
            </para>

            <para>
                In <classname>Zend_Db_Select</classname> können Bedingungen für die Einschränkung
                von Gruppen mit der Methode <methodname>having()</methodname> angegeben werden. Die
                Nutzung ist ähnlich wie die der Methode <methodname>where()</methodname>. Das erste
                Argument ist ein String, welcher einen <acronym>SQL</acronym>-Ausdruck enthält. Das
                zweite Argument ist optional und wird verwendet, um einen
                Platzhalter im <acronym>SQL</acronym>-Ausdruck zu ersetzen. Ausdrücke, die
                durch mehrfaches Aufrufen der Methode <methodname>having()</methodname> erzeugt
                wurden, werden mit dem Boolschen Operator <acronym>AND</acronym> verknüpft, oder mit
                dem Operator <acronym>OR</acronym>, wenn die Methode
                <methodname>orHaving()</methodname> verwendet wird.
            </para>

            <example id="zend.db.select.building.having.example">
                <title>Beispiel für die Methode having()</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", COUNT(*) AS line_items_per_product
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id
//   HAVING line_items_per_product > 10

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array('line_items_per_product' => 'COUNT(*)'))
             ->group('p.product_id')
             ->having('line_items_per_product > 10');
]]></programlisting>
            </example>

            <note>
                <para>
                    Es wird keine Quotierung auf Ausdrücke angewendet, welche an die Methoden
                    <methodname>having()</methodname> oder <methodname>orHaving()</methodname>
                    übergeben werden. Werden Spaltennamen verwendet, die quotiert werden
                    müssen, so muss <methodname>quoteIdentifier()</methodname> verwendet werden,
                    wenn der String für die Bedingung formuliert wird.
                </para>
            </note>
        </sect3>

        <sect3 id="zend.db.select.building.order">
            <title>Hinzufügen eines ORDER BY Abschnitts</title>

            <para>
                In <acronym>SQL</acronym> gibt der <acronym>ORDER</acronym> BY Abschnitt eine oder
                mehrere Spalten oder Ausdrücke an, wonach ein Ergebnissatz sortiert wird. Wenn
                mehrere Spalten angegeben sind, werden die sekundären Spalten verwendet um "ties"
                aufzulösen; die Sortierung wird von sekundären Spalten bestimmt, wenn vorhergehende
                Spalten identische Werte enthalten. Die Standardsortierung ist vom kleinsten zum
                größten Wert. Dieses Verhalten kann umgekehrt werden, wenn das Schlüsselwort
                <constant>DESC</constant> nach der Spalte angegeben wird.
            </para>

            <para>
                In <classname>Zend_Db_Select</classname> kann die Methode
                <methodname>order()</methodname> verwendet werden um Spalten oder Arrays von Spalten
                anzugeben, nach denen sortiert werden soll. Jedes Element des Arrays ist ein String,
                welcher die Spalte benennt. Optional kann auf den Namen eines der Schlüsselwörter
                <constant>ASC</constant> <constant>DESC</constant> getrennt durch ein
                Leerzeichen folgen.
            </para>

            <para>
                Wie in den Methoden <methodname>from()</methodname> und
                <methodname>group()</methodname> werden Spalten als Bezeichner quotiert, wenn sie
                nicht von runden Klammern eingeschlossen oder vom Objekttyp
                <classname>Zend_Db_Expr</classname> sind.
            </para>

            <example id="zend.db.select.building.order.example">
                <title>Beispiel für die Methode order()</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", COUNT(*) AS line_items_per_product
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id
//   ORDER BY "line_items_per_product" DESC, "product_id"

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array('line_items_per_product' => 'COUNT(*)'))
             ->group('p.product_id')
             ->order(array('line_items_per_product DESC',
                           'product_id'));
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.limit">
            <title>Hinzufügen eines LIMIT-Abschnitts</title>

            <para>
                Einige <acronym>RDBMS</acronym>-Marken erweitern <acronym>SQL</acronym> mit einem
                Anfrageabschnitt, bekannt als <constant>LIMIT</constant>-Abschnitt. Dieser
                Abschnitt begrenzt die Anzahl der Zeilen in einem Ergebnissatz auf die angegebene
                Höchstanzahl. Es kann ebenfalls angegeben werden, dass eine Anzahl von Zeilen
                ausgelassen werden soll. Dieses Feature erlaubt es, eine Untermenge des
                Ergebnissatzes zu holen, zum Beispiel wenn Anfrageergebnisse auf einander
                folgenden Seiten angezeigt werden sollen.
            </para>

            <para>
                In <classname>Zend_Db_Select</classname> kann die Methode
                <methodname>limit()</methodname> verwendet werden, um die Anzahl von Zeilen und die
                Anzahl der auszulassenden Spalten anzugeben. Das <emphasis>erste</emphasis> Argument
                dieser Methode ist die gewünschte Anzahl an Zeilen. Das <emphasis>zweite</emphasis>
                Argument gibt die Anzahl der auszulassenden Zeilen an.
            </para>

            <example id="zend.db.select.building.limit.example">
                <title>Beispiel für die Methode limit()</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p
//   LIMIT 10, 20
// Identisch zu:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p
//   LIMIT 20 OFFSET 10

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->limit(20, 10);
]]></programlisting>
            </example>

            <note>
                <para>
                    Die <constant>LIMIT</constant>-Syntax wird nicht von allen
                    <acronym>RDBMS</acronym>-Marken unterstützt. Einige <acronym>RDBMS</acronym>
                    benötigen eine unterschiedliche Syntax für eine ähnliche Funktionalität. Jede
                    <classname>Zend_Db_Adapter_Abstract</classname>-Klasse enthält eine Methode um
                    die für das <acronym>RDBMS</acronym> passende <acronym>SQL</acronym>-Syntax zu
                    erzeugen.
                </para>
            </note>

            <para>
                Die Methode <methodname>limitPage()</methodname> kann als alternativer Weg
                verwendet werden, um Zeilenanzahl und Offset zu anzugeben. Diese Methode erlaubt es,
                den Ergebnissatz auf ein Subset aus einer Serie von Subsets mit Reihen einer
                fixen Länge aus dem Gesamtergebnis zu begrenzen. In anderen
                Worten gibt man die Länge einer Seite ("page") und die
                Nummer der Seite an, die als Ergebnis von der Abfrage
                zurückgegeben werden sollen. Die Seitennummer ist das erste Argument der
                Methode <methodname>limitPage()</methodname>, die Seitenlänge ist das zweite
                Argument. Beide Argumente werden benötigt; sie haben keinen Standardwert.
            </para>

            <example id="zend.db.select.building.limit.example2">
                <title>Beispiel der Methode limitPage()</title>

                <programlisting language="php"><![CDATA[
// Erstelle diese Abfrage:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p
//   LIMIT 10, 20

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->limitPage(2, 10);
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.distinct">
            <title>Hinzufügen des Anfragewandlers DISTINCT</title>

            <para>
                Die Methode <methodname>distinct()</methodname> ermöglicht es, das
                Schlüsselwort <constant>DISTINCT</constant> in die <acronym>SQL</acronym>-Syntax
                einzufügen.
            </para>

            <example id="zend.db.select.building.distinct.example">
                <title>Beispiel für die Methode distinct()</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT DISTINCT p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->distinct()
             ->from(array('p' => 'products'), 'product_name');
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.for-update">
            <title>Hinzufügen des Anfragewandlers FOR UPDATE</title>

            <para>
                Die Methode <methodname>forUpdate()</methodname> ermöglicht es, die
                Schlüsselworte <acronym>FOR</acronym> <acronym>UPDATE</acronym> in die
                <acronym>SQL</acronym>-Syntax einzufügen.
            </para>

            <example id="zend.db.select.building.for-update.example">
                <title>Beispiel der Methode forUpdate()</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT FOR UPDATE p.*
//   FROM "products" AS p

$select = $db->select()
             ->forUpdate()
             ->from(array('p' => 'products'));
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.building.union">
            <title>Eine UNION-Abfrage erstellen</title>

            <para>
                Man kann Union-Abfragen mit <classname>Zend_Db_Select</classname> erstellen, indem
                ein Array von <classname>Zend_Db_Select</classname> oder <acronym>SQL</acronym>
                Query Strings an die Methode <methodname>union()</methodname> übergeben wird. Als
                zweiter Parameter können die Konstanten
                <constant>Zend_Db_Select::SQL_UNION</constant> oder
                <constant>Zend_Db_Select::SQL_UNION_ALL</constant> übergeben werden, um den Typ der
                Union zu anzugeben, den man ausführen will.
            </para>

            <example id="zend.db.select.building.union.example">
                <title>Beispiel der Methode union()</title>

                <programlisting language="php"><![CDATA[
$sql1 = $db->select();
$sql2 = "SELECT ...";

$select = $db->select()
    ->union(array($sql1, $sql2))
    ->order("id");
]]></programlisting>
            </example>
        </sect3>
    </sect2>

    <sect2 id="zend.db.select.execute">
        <title>Ausführen von SELECT-Anfragen</title>

        <para>
            Dieser Abschnitt beschreibt, wie Anfragen ausgeführt werden, die durch ein
            <classname>Zend_Db_Select</classname>-Objekt repräsentiert werden.
        </para>

        <sect3 id="zend.db.select.execute.query-adapter">
            <title>Ausführen von Select-Anfragen aus dem Db-Adapter</title>

            <para>
                Die Anfrage, die durch das <classname>Zend_Db_Select</classname>-Objekt
                repräsentiert wird, kann ausgeführt werden, indem sie als erstes Argument an die
                Methode <methodname>query()</methodname> des
                <classname>Zend_Db_Adapter_Abstract</classname>-Objekts übergeben wird. Dabei wird
                das <classname>Zend_Db_Select</classname> anstelle eines Strings verwendet.
            </para>

            <para>
                Die Methode <methodname>query()</methodname> gibt ein Objekt vom Typ
                <classname>Zend_Db_Statement</classname> oder PDOStatement
                zurück, je nachdem welcher Adaptertyp verwendet wird.
            </para>

            <example id="zend.db.select.execute.query-adapter.example">
                <title>Beispiel für die Nutzung der Methode query() des Db-Adapters</title>

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('products');

$stmt = $db->query($select);
$result = $stmt->fetchAll();
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.execute.query-select">
            <title>Ausführen von Select-Anfragen mit dem Objekt</title>

            <para>
                Als Alternative zur Nutzung der Methode <methodname>query()</methodname> des
                Adapterobjekts kann auch die Methode <methodname>query()</methodname> des
                Objekts <classname>Zend_Db_Select</classname> verwendet werden. Beide Methoden
                geben ein Objekt vom Typ <classname>Zend_Db_Statement</classname> oder
                PDOStatement zurück, je nachdem welcher Adaptertyp verwendet wird.
            </para>

            <example id="zend.db.select.execute.query-select.example">
                <title>Beispiel für die Nutzung der Methode query() des Select-Objekts</title>

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('products');

$stmt = $select->query();
$result = $stmt->fetchAll();
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.execute.tostring">
            <title>Konvertieren eines Select-Objekts in einen SQL-String</title>

            <para>
                Wenn Zugriff auf die String-Repräsentation der <acronym>SQL</acronym>-Anfrage
                benötigt wird, welche dem Objekt <classname>Zend_Db_Select</classname> entspricht,
                kann die Methode <methodname>__toString()</methodname> verwendet werden.
            </para>

            <example id="zend.db.select.execute.tostring.example">
                <title>Beispiel für die Methode __toString()</title>

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('products');

$sql = $select->__toString();
echo "$sql\n";

// Ausgabe ist dieser String:
//   SELECT * FROM "products"
]]></programlisting>
            </example>
        </sect3>
    </sect2>

    <sect2 id="zend.db.select.other">
        <title>Andere Methoden</title>

        <para>
            Dieser Abschnitt beschreibt andere Methoden der <classname>Zend_Db_Select</classname>
            Klasse, welche bisher nicht beschrieben wurden: <methodname>getPart()</methodname> und
            <methodname>reset()</methodname>.
        </para>

        <sect3 id="zend.db.select.other.get-part">
            <title>Abfragen von Teilen des Select-Objekts</title>

            <para>
                Die Methode <methodname>getPart()</methodname> gibt eine Repräsentation eines Teils
                der <acronym>SQL</acronym>-Anfrage zurück. Zum Beispiel kann diese Methode verwendet
                werden um ein Array von Ausdrücke des <constant>WHERE</constant>-Abschnitts, ein
                Array von Spalten (oder Spaltenausdrücke) von <constant>SELECT</constant> oder
                die Werte der Spaltenzahl und Auslassungen des <constant>LIMIT</constant>-Abschnitts
                zu erhalten.
            </para>

            <para>
                Die Rückgabe ist kein String, der ein Fragment der <acronym>SQL</acronym>-Syntax
                enthält. Der Rückgabewert ist eine interne Repräsentation, was typischerweise eine
                Arraystruktur ist, welche Werte und Ausdrücke enthält. Jeder Teil der Anfrage hat
                eine unterschiedliche Struktur.
            </para>

            <para>
                Das einzige Argument der Methode <methodname>getPart()</methodname> ist ein String,
                der den zurückzugebenden Teil der Anfrage bezeichnet. Zum Beispiel bezeichnet der
                String <command>'from'</command> den Teil des Select-Objekts, welcher Informationen
                über den <constant>FROM</constant>-Abschnitt, einschließlich verbundener Tabellen
                enthält.
            </para>

            <para>
                Die Klasse <classname>Zend_Db_Select</classname> definiert Konstanten, die für Teile
                der <acronym>SQL</acronym>-Anfrage verwendet werden können. Es können die
                Konstantendefinitionen oder die literalen Strings verwendet werden.
            </para>

            <table id="zend.db.select.other.get-part.table">
                <title>Konstanten, die von getPart() und reset() verwendet werden</title>

                <tgroup cols="2">
                    <thead>
                        <row>
                            <entry>Konstante</entry>
                            <entry>String Wert</entry>
                        </row>
                    </thead>

                    <tbody>
                        <row>
                            <entry><constant>Zend_Db_Select::DISTINCT</constant></entry>
                            <entry><command>'distinct'</command></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::FOR_UPDATE</constant></entry>
                            <entry><command>'forupdate'</command></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::COLUMNS</constant></entry>
                            <entry><command>'columns'</command></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::FROM</constant></entry>
                            <entry><command>'from'</command></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::WHERE</constant></entry>
                            <entry><command>'where'</command></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::GROUP</constant></entry>
                            <entry><command>'group'</command></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::HAVING</constant></entry>
                            <entry><command>'having'</command></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::ORDER</constant></entry>
                            <entry><command>'order'</command></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::LIMIT_COUNT</constant></entry>
                            <entry><command>'limitcount'</command></entry>
                        </row>

                        <row>
                            <entry><constant>Zend_Db_Select::LIMIT_OFFSET</constant></entry>
                            <entry><command>'limitoffset'</command></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <example id="zend.db.select.other.get-part.example">
                <title>Beispiel der Methode getPart()</title>

                <programlisting language="php"><![CDATA[
$select = $db->select()
             ->from('products')
             ->order('product_id');

// Ein literaler String kann verwendet werden, um den Abschnitt zu definieren
$orderData = $select->getPart( 'order' );

// Eine Konstante kann verwendet werden, um denselben Abschnitt zu definieren
$orderData = $select->getPart( Zend_Db_Select::ORDER );

// Der zurückgegebene Wert kann eine Arraystruktur sein, kein String.
// Jeder Abschnitt hat eine unterschiedliche Struktur.
print_r( $orderData );
]]></programlisting>
            </example>
        </sect3>

        <sect3 id="zend.db.select.other.reset">
            <title>Zurücksetzen von Teilen des Select-Objekts</title>

            <para>
                Die Methode <methodname>reset()</methodname> ermöglicht es, einen angegebenen Teil
                der <acronym>SQL</acronym>-Anfrage zu löschen oder, wenn der Parameter ausgelassen
                ist, alle Teile der <acronym>SQL</acronym>-Anfrage zu löschen.
            </para>

            <para>
                Das einzige Argument ist optional. Es kann der Teil der Anfrage angegeben werden,
                der gelöscht werden soll, unter Nutzung des gleichen Strings wie er als Argument
                der Methode <methodname>getPart()</methodname> verwendet wird. Der angegebene Teil
                wird auf einen Standardwert zurück gesetzt.
            </para>

            <para>
                Wenn der Parameter ausgelassen wird, setzt <methodname>reset()</methodname> alle
                geänderten Teile auf einen Standardwert zurück. Dadurch ist das
                <classname>Zend_Db_Select</classname>-Objekt gleichwertig mit einem neuen Objekt,
                wie wenn es gerade instanziiert wurde.
            </para>

            <example id="zend.db.select.other.reset.example">
                <title>Beispiel der Methode reset()</title>

                <programlisting language="php"><![CDATA[
// Erzeugt diese Anfrage:
//   SELECT p.*
//   FROM "products" AS p
//   ORDER BY "product_name"

$select = $db->select()
             ->from(array('p' => 'products')
             ->order('product_name');

// Geänderte Anforderungen, stattdessen sortiert nach einer anderen Spalte:
//   SELECT p.*
//   FROM "products" AS p
//   ORDER BY "product_id"

// Lösche einen Abschnitt, damit er neu defniert werden kann
$select->reset( Zend_Db_Select::ORDER );

// und definiere eine andere Spalte
$select->order('product_id');

// Lösche alle Abschnitte von der Abfrage
$select->reset();
]]></programlisting>
            </example>
        </sect3>
    </sect2>
</sect1>
