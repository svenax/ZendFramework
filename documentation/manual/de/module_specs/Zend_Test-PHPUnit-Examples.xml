<!-- EN-Revision: 10125 -->
<sect2 id="zend.test.phpunit.examples">
    <title>Beispiele</title>

    <para>
        Zu wissen wir man die eigene Infrastruktur für Tests einstellt und wir Ausnahmen zu erstellen sind ist
        nur der halbe Kampf; jetzt ist es Zeit auf einige Testszenarien zu schauen und zu eruieren wie diese
        verwendet werden können.
    </para>

    <example id="zend.test.phpunit.examples.userController">
        <title>Den UserController testen</title>

        <para>
            Nehmen wir einen standard Task für eine Webseite an: Authentifizierung und Registrierung von
            Benutzern. In unserem Beispiel definieren wir einen UserController um das zu behandeln, und haben
            die folgenden Notwendigkeiten:
        </para>

        <itemizedlist>
            <listitem><para>
                Wenn ein Benutzer nicht authentifiziert ist, wird er immer zur Login Seite des Kontrollers
                umgeleitet, unabhängig von der spezifizierten Aktion.
            </para></listitem>

            <listitem><para>
                Die Login Formularseite wird beides zeigen, das Login Formular und das Registrations Formular.
            </para></listitem>

            <listitem><para>
                Die angabe von ungültigen Anmeldedaten sollte in der Rückgabe des Login Formulars resultieren.
            </para></listitem>

            <listitem><para>
                Das Ansehen der Anmeldedaten sollte in einer Umleitung zur Profilseite des Benutzers resultieren.
            </para></listitem>

            <listitem><para>
                Die Profilseite sollte verändert werden um den Benutzernamen des Benutzers zu enthalten.
            </para></listitem>

            <listitem><para>
                Authentifizierte Benutzer welche die Loginseite besuchen sollten zu Ihrer Profilseite
                umgeleitet werden.
            </para></listitem>

            <listitem><para>
                Bei der Abmeldung, sollten ein Benutzer zur Loginseite umgeleitet werden.
            </para></listitem>

            <listitem><para>
                Mit ungültigen Daten sollte die Registrierung fehlschlagen.
            </para></listitem>
        </itemizedlist>

        <para>
            Wir können, und sollten zusätzliche Tests definieren, aber diese reichen für jetzt.
        </para>

        <para>
            Für unsere Anwendung definieren wir ein Plugin, 'Initialisieren' es, damit es bei
            <code>routeStartup()</code> läuft. Das erlaubt es uns das Bootstrapping in einem OOP Interface
            zu kapseln, was auch einen einfachen Weg bietet um ein Callback zu ermöglichen. Schauen wir uns
            erstmals die Basics dieser Klasse an:
        </para>

        <programlisting role="php"><![CDATA[
class Bugapp_Plugin_Initialize extends Zend_Controller_Plugin_Abstract
{
    /**
     * @var Zend_Config
     */
    protected static $_config;

    /**
     * @var string Aktuelle Umgebung
     */
    protected $_env;

    /**
     * @var Zend_Controller_Front
     */
    protected $_front;

    /**
     * @var string Pfad zum Root der Anwendung
     */
    protected $_root;

    /**
     * Constructor
     *
     * Umgebung, Root Pfad und Konfiguration initialisieren
     * 
     * @param  string $env 
     * @param  string|null $root 
     * @return void
     */
    public function __construct($env, $root = null)
    {
        $this->_setEnv($env);
        if (null === $root) {
            $root = realpath(dirname(__FILE__) . '/../../../');
        }
        $this->_root = $root;

        $this->initPhpConfig();

        $this->_front = Zend_Controller_Front::getInstance();
    }

    /**
     * Route beginnen
     * 
     * @return void
     */
    public function routeStartup(Zend_Controller_Request_Abstract $request)
    {
        $this->initDb();
        $this->initHelpers();
        $this->initView();
        $this->initPlugins();
        $this->initRoutes();
        $this->initControllers();
    }

    // Die Definition von Methoden würde hier folgen...
}
]]></programlisting>

        <para>
            Das erlaubt es uns einen Bootstrap Callback wie folgt zu erstellen:
        </para>

        <programlisting role="php"><![CDATA[
class UserControllerTest extends Zend_Test_PHPUnit_ControllerTestCase
{
    public function appBootstrap()
    {
        $controller = $this->getFrontController();
        $controller->registerPlugin(new Bugapp_Plugin_Initialize('development'));
    }

    public function setUp()
    {
        $this->bootstrap = array($this, 'appBootstrap');
        parent::setUp();
    }

    // ...
}
]]></programlisting>

        <para>
            Once we have that in place, we can write our tests. However, what
            about those tests that require a user is logged in? The easy
            solution is to use our application logic to do so... and fudge a
            little by using the <code>resetResponse()</code> method, which will
            allow us to dispatch another request.
        </para>

        <programlisting role="php"><![CDATA[
class UserControllerTest extends Zend_Test_PHPUnit_ControllerTestCase
{
    // ...

    public function loginUser($user, $password)
    {
        $request = $this->getRequest();
        $request->setMethod('POST')
                ->setPost(array(
                    'username' => $user,
                    'password' => $password,
                ));
        $this->dispatch('/user/login');
        $this->assertRedirectTo('/user/view');
        $this->resetResponse();
        $request->setPost(array());
    }

    // ...
}
]]></programlisting>
        
        <para>
            Now let's write tests:
        </para>

        <programlisting role="php"><![CDATA[
class UserControllerTest extends Zend_Test_PHPUnit_ControllerTestCase
{
    // ...

    public function testCallWithoutActionShouldPullFromIndexAction()
    {
        $this->dispatch('/user');
        $this->assertController('user');
        $this->assertAction('index');
    }

    public function testLoginFormShouldContainLoginAndRegistrationForms()
    {
        $this->dispatch('/user');
        $this->assertQueryCount('form', 2);
    }

    public function testInvalidCredentialsShouldResultInRedisplayOfLoginForm()
    {
        $request = $this->getRequest();
        $request->setMethod('POST')
                ->setPost(array(
                    'username' => 'bogus',
                    'password' => 'reallyReallyBogus',
                ));
        $this->dispatch('/user/login');
        $this->assertNotRedirect();
        $this->assertQuery('form');
    }

    public function testValidLoginShouldRedirectToProfilePage()
    {
        $this->loginUser('foobar', 'foobar');
    }

    public function testAuthenticatedUserShouldHaveCustomizedProfilePage()
    {
        $this->loginUser('foobar', 'foobar');
        $this->request->setMethod('GET');
        $this->dispatch('/user/view');
        $this->assertNotRedirect();
        $this->assertQueryContentContains('h2', 'foobar');
    }

    public function testAuthenticatedUsersShouldBeRedirectedToProfilePageWhenVisitingLoginPage()
    {
        $this->loginUser('foobar', 'foobar');
        $this->request->setMethod('GET');
        $this->dispatch('/user');
        $this->assertRedirectTo('/user/view');
    }

    public function testUserShouldRedirectToLoginPageOnLogout()
    {
        $this->loginUser('foobar', 'foobar');
        $this->request->setMethod('GET');
        $this->dispatch('/user/logout');
        $this->assertRedirectTo('/user');
    }

    public function testRegistrationShouldFailWithInvalidData()
    {
        $data = array(
            'username' => 'This will not work',
            'email'    => 'this is an invalid email',
            'password' => 'Th1s!s!nv@l1d',
            'passwordVerification' => 'wrong!',
        );
        $request = $this->getRequest();
        $request->setMethod('POST')
                ->setPost($data);
        $this->dispatch('/user/register');
        $this->assertNotRedirect();
        $this->assertQuery('form .errors');
    }
}
]]></programlisting>

        <para>
            Notice that these are terse, and, for the most part, don't look for
            actual content. Instead, they look for artifacts within the
            response -- response codes and headers, and DOM nodes. This allows
            you to verify that the structure is as expected -- preventing your
            tests from choking every time new content is added to the site.
        </para>

        <para>
            Also notice that we use the structure of the document in our tests.
            For instance, in the final test, we look for a form that has a node
            with the class of "errors"; this allows us to test merely for the
            presence of form validation errors, and not worry about what
            specific errors might have been thrown.
        </para>

        <para>
            This application <emphasis>may</emphasis> utilize a database. If
            so, you will probably need some scaffolding to ensure that the
            database is in a pristine, testable configuration at the beginning
            of each test. PHPUnit already provides functionality for doing so;
            <ulink
                url="http://www.phpunit.de/pocket_guide/3.3/en/database.html">read
                about it in the PHPUnit documentation</ulink>. We recommend
            using a separate database for testing versus production, and in
            particular recommend using either a SQLite file or in-memory
            database, as both options perform very well, do not require a
            separate server, and can utilize most SQL syntax.
        </para>
    </example>
</sect2>
<!--
vim:se ts=4 sw=4 et:
-->
