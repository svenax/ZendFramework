<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 15103 -->
<!-- Reviewed: no -->
<sect1 id="zend.json.advanced">
    <title>Fortgeschrittene Verwendung von Zend_Json</title>

    <sect2 id="zend.json.advanced.objects1">
        <title>JSON Objekte</title>

        <para>
            Bei der Kodierung von PHP Objekten nach JSON werden alle öffentlichen Eigenschaften
            dieses Objektes im JSON Objekt kodiert.
        </para>

        <para>
            JSON erlaubt keine Objektreferenzen, deshalb sollte dafür Sorge getragen werden, dass
            keine Objekte mit rekursiver Referenz kodiert werden. Wenn man Probleme mit Rekursion
            hat, erlauben <classname>Zend_Json::encode()</classname> und
            <classname>Zend_Json_Encoder::encode()</classname> die Angabe eines optionalen, zweiten
            Parameters, um auf Rekursion zu prüfen; wenn ein Objekt doppelt serialisiert wird, wird
            eine Ausnahme geworfen.
        </para>

        <para>
            Das Dekodieren von JSON Objekten stellt eine weitere Schwierigkeit dar, allerdings
            entsprechen Javascript Objekte sehr einem assoziativen Array in PHP. Einige schlagen
            vor, dass ein Klassenbezeichner übergeben werden soll und eine Objektinstanz dieser
            Klasse erstellt und mit den Schlüssel/Wert Paaren des JSON Objektes bestückt werden
            soll; andere denken, dies könnte ein erhebliches Sicherheitsrisiko darstellen.
        </para>

        <para>
            Standardmäßig wird <classname>Zend_Json</classname> die JSON Objekte als assoziative Arrays
            dekodieren. Wenn du allerdings wünscht, dass ein Objekt zurück gegeben wird, kannst du
            dies angeben:
        </para>

        <programlisting role="php"><![CDATA[
// Dekodiere JSON Objekte als PHP Objekte
$phpNative = Zend_Json::decode($encodedValue, Zend_Json::TYPE_OBJECT);
]]>
        </programlisting>

        <para>
            Jedes dekodierte Objekte wird als <code>StdClass</code> Objekt mit Eigenschaften
            entsprechend der Schlüssel/Wert Paare der JSON Notation zuürckgegeben.
        </para>

        <para>
            Die Empfehlung des Zend Framework ist, dass der einzelne Entwickler selber entscheiden
            sollte, wie er JSON Objekte dekodiert. Wenn ein Objekt eines bestimmten Typs erstellt werden
            soll, kann es im Code des Entwicklers erstellt werden und mit den dekodierten Werten unter
            Verwendung von <classname>Zend_Json</classname> bestückt werden.
        </para>
    </sect2>

    <sect2 id="zend.json.advanced.objects2">
        <title>Kodierung von PHP Objekten</title>

        <para>
            Wenn man PHP Objekte kodiert, kann der Kodierungsmechanismus standardmäßig nur auf
            public Eigenschaften dieser Objekte zugreifen. Wenn eine Methode <code>toJson()</code>
            an einem Objekte für die Kodierung implementiert ist, ruft <classname>Zend_Json</classname> diese
            Methode auf und erwartet dass das Objekt eine JSON Repräsentation seines internen
            Status zurückgibt.
        </para>
    </sect2>

    <sect2 id="zend.json.advanced.internal">
        <title>Interner Encoder/Decoder</title>

        <para>
            Zend_Json hat zwei unterschiedliche Modi abhängig davon ob ext/json in der PHP
            Installation aktiviert ist oder nicht. Wenn ext/json installiert ist, werden
            standardmäßig die Funktionen <code>json_encode()</code> und <code>json_decode()</code>
            für die Kodierung und Dekodierung von JSON verwendet. Wenn ext/json nicht installiert
            ist wird eine Implentierung vom Zend Framework in PHP Code für die De-/Kodierung
            verwendet. Das ist naturgemäß langsamer als die Verwendung der PHP Erweiterung, verhält
            sich aber identisch.
        </para>

        <para>
            Machmal will man trotzdem den internen De-/Kodierer verwenden, selbst wenn man ext/json
            installiert hat. Man kann das durch folgenden Aufruf erzwingen:
        </para>

        <programlisting role="php"><![CDATA[
Zend_Json::$useBuiltinEncoderDecoder = true:
]]>
        </programlisting>
    </sect2>

    <sect2 id="zend.json.advanced.expr">
        <title>JSON Ausdrücke</title>

        <para>
            Javascript macht häufige Verwendung von anonymen Funktions-Callbacks, welche in
            JSON Objektvariablen gespeichert werden können. Trotzdem funktionieren Sie nur wenn
            Sie nicht in doppelten Anführungszeichen gesetzt werden, was <classname>Zend_Json</classname>
            natürlich macht. Mit der Unterstützung von Ausdrücken für Zend_Json können JSON Objekte
            mit gültigen Javascript Callbacks kodiert werden. Das funktioniert sowohl für
            <code>json_encode()</code> als auch den internen Kodierer.
        </para>

        <para>
            Ein Javascript Callback wird repräsentiert indem das <classname>Zend_Json_Expr</classname> Objekt
            verwendet wird. Es implementiert das Wert-Objekt Pattern und ist nicht änderbar. Man
            kann den Javascript Ausdruck als erstes Argument des Konstruktors setzen. Standardmäßig
            kodiert <classname>Zend_Json::encode</classname> keine Javascript Callbacks, wenn man die Option
            <code>'enableJsonExprFinder' = true</code> in der <code>encode</code> Funktion
            übergibt. Aktiviert, unterstützt arbeiten Ausdrücke für alle enthaltenen Ausdrücke in
            großen Objektstrukturen. Ein Verwendungsbeispiel würde wie folgt aussehen:
        </para>

        <programlisting role="php"><![CDATA[
$data = array(
    'onClick' => new Zend_Json_Expr('function() { '
              . 'alert("Ich bin ein gültiger Javascript Callback '
              . 'erstellt von Zend_Json"); }'),
    'other' => 'no expression',
);
$jsonObjectWithExpression = Zend_Json::encode(
    $data,
    false,
    array('enableJsonExprFinder' => true)
);
]]>
        </programlisting>
    </sect2>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->