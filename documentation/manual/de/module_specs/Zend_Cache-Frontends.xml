<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 15617 -->
<!-- Reviewed: no -->
<sect1 id="zend.cache.frontends">
    <title>Zend_Cache Frontends</title>

    <sect2 id="zend.cache.frontends.core">
        <title>Zend_Cache_Core</title>
        <sect3 id="zend.cache.frontends.core.introduction">
            <title>Einführung</title>
            <para>
                <classname>Zend_Cache_Core</classname> ist ein spezielles Frontend, da es der Kern
                dieses Moduls ist. Es ist ein generelles Cache Frontend und wurde von anderen
                Klassen erweitert.
            </para>
            <note>
                <para>
                    Alle Frontends sind von <classname>Zend_Cache_Core</classname> abgeleitet, so
                    dass deren Methoden und Optionen (wie folgt beschrieben) auch in anderen
                    Frontends vorhanden sind. Deswegen werden sie dort nicht dokumentiert.
                </para>
            </note>
        </sect3>
        <sect3 id="zend.cache.frontends.core.options">
            <title>Mögliche Optionen</title>
            <para>
                Diese Optionen werden der Factory Methode übergeben wie im nachfolgenden Beispiel
                demonstriert.
            </para>
            <table id="zend.cache.frontends.core.options.table">
                <title>Core Frontend Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>caching</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  Ein- / Ausschalten vom Caching (kann sehr nützlich für das
                                  Debuggen von gecachten Skripten sein)
                              </entry>
                          </row>
                          <row>
                              <entry><code>cache_id_prefix</code></entry>
                              <entry><code>string</code></entry>
                              <entry><code>null</code></entry>
                              <entry>
                                  Ein Präfix für alle Cache IDs. Wenn er auf <code>null</code>
                                  gesetzt wird, wird kein Cache ID Präfix verwendet. Der Cache ID
                                  Präfix erstellt grundsätzlich einen Namespace im Cache, der
                                  verschiedenen Anwendungen oder Websites die Verwendung eines
                                  gemeinsamen Caches erlaubt. Jede Anwendung oder Website kann
                                  einen anderen Cache ID Prüfix verwenden sodas spezielle Cache IDs
                                  mehr als einmal verwendet werden können.
                              </entry>
                          </row>
                          <row>
                              <entry><code>lifetime</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>3600</code></entry>
                              <entry>
                                Cache Lebensdauer (in Sekunden), wenn auf <code>null</code> gesetzt,
                                ist der Cache für immer gültig.
                              </entry>
                          </row>
                          <row>
                              <entry><code>logging</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Wenn auf true gesetzt, wird das Logging durch
                                <classname>Zend_Log</classname> aktiviert (aber das System wird
                                langsamer)
                              </entry>
                          </row>
                          <row>
                              <entry><code>write_control</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                Ein- / Ausschalten der Schreibkontrolle (der Cache wird gleich
                                gelesen, nachdem er geschrieben wurde, um fehlerhafte Einträge zu
                                finden); das Einschalten der Schreibkontrolle wird das Schreiben des
                                Caches etwas verlangsamen, aber nicht das Lesen des Caches (es
                                können defekte Cache Dateien entdeckt werden, aber es ist keine
                                perfekte Kontrolle)
                              </entry>
                          </row>
                          <row>
                              <entry><code>automatic_serialization</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Ein- / Ausschalten der automatischen Serialisierung, kann dafür
                                benutzt werden, um Daten direkt zu speichern, welche keine Strings
                                sind (aber es ist langsamer)
                              </entry>
                          </row>
                          <row>
                              <entry><code>automatic_cleaning_factor</code></entry>
                              <entry><code>int</code></entry>
                              <entry><code>10</code></entry>
                              <entry>
                                Ausschalten / Abgleichen des automatischen Löschprozesses (Garbage
                                Collector): 0 heißt keine automatische Löschung des Caches, 1 heißt
                                Systematische Cache Löschung und x &gt; 1 heißt automatisches
                                zufälliges Löschen 1 mal nach x Schreiboperationen.
                              </entry>
                          </row>
                          <row>
                              <entry><code>ignore_user_abort</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                Auf true gesetzt, wird der Kern das PHP Flag ignore_user_abort
                                innerhalb der save() Methode setzen um Cache Korruption in einigen
                                Fällen zuverhindern
                              </entry>
                          </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.core.examples">
            <title>Beispiele</title>
            <para>
                Ein Beispiel wird ganz am Anfang des Handbuches gegeben.
            </para>
            <para>
                Wenn nur Strings in den Cache gespeichert werden (denn mit der
                "automatic_serialization" Option wäre es möglich Booleans zu speichern), kann ein
                kompakterer Weg wie folgt gewählt werden:
            </para>
                 <programlisting language="php"><![CDATA[
// Es wird angenommen das $cache existiert

$id = 'myBigLoop'; // Die Cache ID von dem "das gecached werden soll"

if (!($data = $cache->load($id))) {
    // Cache miss

    $data = '';
    for ($i = 0; $i < 10000; $i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}

// [...] Irgendwas mit $data machen (ausgeben, verarbeiten, usw.)
]]></programlisting>
            <para>
                Wenn mehrere Blöcke von Daten oder Daten Instanzen gecached werden sollen, ist die
                Idee dahinter die gleiche:
            </para>
                 <programlisting language="php"><![CDATA[
// Sicherstellen, dass eindeutige Identifizierer verwendet werden:
$id1 = 'foo';
$id2 = 'bar';

// Block 1
if (!($data = $cache->load($id1))) {
    // Cache miss

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . $i;
    }

    $cache->save($data);

}
echo($data);

// Hier wird NIE gecached
echo('NIE GECACHED! ');

// Block 2
if (!($data = $cache->load($id2))) {
    // Cache miss

    $data = '';
    for ($i=0;$i<10000;$i++) {
        $data = $data . '!';
    }

    $cache->save($data);

}
echo($data);
]]></programlisting>

            <para>
                Wenn spezielle Werte gecached werden sollen (boolean mit der
                "automatic_serialization" Option) oder leere Strings kann die kompakte Erstellung
                wie oben gezeigt nicht verwendet werden. Der Cache Eintrag muß formell getestet
                werden.
            </para>

            <programlisting language="php"><![CDATA[
// Die kompakte Erstellung
// (nicht gut wenn leere Strings und/oder boolsche Werte gecached werden)
if (!($data = $cache->load($id))) {

    // Cache fehlgeschlagen

    // [...] wir erstellen $data

    $cache->save($data);

}

// wir machen etwas mit $data

// [...]

// die komplette Erstellung (funktioniert in jedem Fall)
if (!($cache->test($id))) {

    // Cache fehlgeschlagen

    // [...] wir erstellen $data

    $cache->save($data);

} else {

    // Cache getroffen

    $data = $cache->load($id);

}

// Wir machen irgendetwas mit $data
]]></programlisting>

       </sect3>

    </sect2>

    <sect2 id="zend.cache.frontends.output">
        <title>Zend_Cache_Frontend_Output</title>
        <sect3 id="zend.cache.frontends.output.introduction">
            <title>Einführung</title>
            <para>
                <classname>Zend_Cache_Frontend_Output</classname> ist ein Ausgabe-Empfangendes
                Frontend. Es verwendet den Ausgabe Puffer in PHP, um alles zwischen der
                <code>start()</code> und der <code>end()</code> Methode zu fangen.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.output.options">
            <title>Mögliche Optionen</title>
            <para>
                Dieses Frontend hat keine bestimmten Optionen zusätzlich zu denen von
                <classname>Zend_Cache_Core</classname>.
            </para>
        </sect3>

        <sect3 id="zend.cache.frontends.output.examples">
            <title>Beispiele</title>
            <para>
                Ein Beispiel wird ganz am Anfang des Handbuches gegeben. Hier ist es mit kleinen
                Änderungen:
            </para>
                 <programlisting language="php"><![CDATA[
// Wenn es ein Cache Miss ist, wird das puffern der Ausgabe ausgelöst
if( ! ($cache->start('mypage'))) {

    // Alle wie gewohnt ausgeben
    echo 'Hallo Welt! ';
    echo 'Das wird gecached ('.time().') ';

    $cache->end(); // Ausgabepufferung beenden

}

echo 'Hier wird nie gecached ('.time().').';
]]></programlisting>
            <para>
                Die Verwendung dieser Form ist ziemlich einfach, um Ausgabe caching in einem bereits
                bestehenden Projekt, mit nur wenig oder gar keinen Codeänderungen, zu erhalten.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.function">
        <title>Zend_Cache_Frontend_Function</title>
        <sect3 id="zend.cache.frontends.function.introduction">
            <title>Einführung</title>
            <para>
                <classname>Zend_Cache_Frontend_Function</classname> cached das Ergebnis von
                Funktionsaufrufen. Es hat eine einzelne Hauptmethode genannt <code>call()</code>,
                welche den Funktionsnamen und Parameter für den Aufruf in einem Array entgegennimmt.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.function.options">
            <title>Mögliche Optionen</title>
            <table id="zend.cache.frontends.function.options.table">
                <title>Cache Frontend Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cache_by_default</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  Wenn true, wird der Funktionsaufruf standardmäßig gecached
                              </entry>
                         </row>
                         <row>
                              <entry><code>cached_functions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Funktionsnamen, die immer gecached werden sollen
                              </entry>
                         </row>
                         <row>
                              <entry><code>non_cached_functions</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Funktionsnamen, die nie gecached werden sollen
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.frontends.function.examples">
            <title>Beispiele</title>
            <para>
                Die Verwendung der <code>call()</code> Funktion ist die gleiche, wie die von
                <code>call_user_func_array()</code> in PHP:
            </para>
                 <programlisting language="php"><![CDATA[
$cache->call('veryExpensiveFunc', $params);

// $params ist ein Array
// Für das Aufrufen von veryExpensiveFunc(1, 'foo', 'bar') mit Caching kann,
// z.B. $cache->call('veryExpensiveFunc', array(1, 'foo', 'bar')) benutzt
// werden
]]></programlisting>
            <para>
                <classname>Zend_Cache_Frontend_Function</classname> ist elegant genug, um beides zu
                cachen, den Rückgabewert der Funktion und deren interne Ausgabe.
            </para>
            <note><para>
                Man kann jede eingebaute oder benutzerdefinierte Funktion übergeben, mit ausnahme
                von <code>array()</code>, <code>echo()</code>, <code>empty()</code>,
                <code>eval()</code>, <code>exit()</code>, <code>isset()</code>, <code>list()</code>,
                <code>print()</code> und <code>unset()</code>.
            </para></note>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.class">
        <title>Zend_Cache_Frontend_Class</title>
        <sect3 id="zend.cache.frontends.class.introduction">
            <title>Einführung</title>
            <para>
                <classname>Zend_Cache_Frontend_Class</classname> ist unterschiedlich zu
                <classname>Zend_Cache_Frontend_Function</classname>, weil es das Cachen von Objekten
                und statischen Methodenaufrufen erlaubt.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.class.options">
            <title>Mögliche Optionen</title>
            <table id="zend.cache.frontends.class.options.table">
                <title>Class Frontend Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Datentyp</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>cached_entity</code> (Notwendig)</entry>
                              <entry><code>mixed</code></entry>
                              <entry></entry>
                              <entry>
                                  Wenn auf einen Klassennamen gesetzt, wird eine abstrakte Klasse
                                  gecached und es werden statische Aufrufe verwendet; wenn auf ein
                                  Objekt gesetzt, wird deren Objektmethoden gecached
                              </entry>
                         </row>
                         <row>
                              <entry><code>cache_by_default</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>true</code></entry>
                              <entry>
                                  Wenn true, wird der Aufruf standardmäßig gecached
                              </entry>
                         </row>
                         <row>
                              <entry><code>cached_methods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Methodennamen, die immer gecached werden sollen
                              </entry>
                         </row>
                         <row>
                              <entry><code>non_cached_methods</code></entry>
                              <entry><code>array</code></entry>
                              <entry></entry>
                              <entry>
                                  Methodennamen, die nie gecached werden sollen
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>

        <sect3 id="zend.cache.frontends.class.examples">
            <title>Beispiele</title>
            <para>
                zum Beispiel, um einen statischen Aufruf zu cachen:
            </para>
                <programlisting language="php"><![CDATA[
class Test {

    // Statische Methode
    public static function foobar($param1, $param2) {
        echo "foobar_output($param1, $param2)";
        return "foobar_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' => 'Test' // Der Name der Klasse
);
// [...]

// Der gecachte Aufruf
$result = $cache->foobar('1', '2');
]]></programlisting>
            <para>
                Um klassische Methodenaufrufe zu cachen :
            </para>
                <programlisting language="php"><![CDATA[
class Test {

    private $_string = 'Hallo !';

    public function foobar2($param1, $param2) {
        echo($this->_string);
        echo "foobar2_output($param1, $param2)";
        return "foobar2_return($param1, $param2)";
    }

}

// [...]
$frontendOptions = array(
    'cached_entity' => new Test() // Eine Instanz der Klasse
);
// [...]

// Der gecachte Aufruf
$res = $cache->foobar2('1', '2');
]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.file">
        <title>Zend_Cache_Frontend_File</title>
        <sect3 id="zend.cache.frontends.file.introduction">
            <title>Einführung</title>
            <para>
                <classname>Zend_Cache_Frontend_File</classname> ist ein Frontend angetrieben durch
                den Änderungszeitpunkt einer "Masterdatei". Es ist wirklich interessant für
                Beispiele in Konfigurations- oder Templateanwendungen. Es ist auch möglich mehrere
                Masterdateien zu verwenden.
            </para>
            <para>
                Zum Beispiel eine XML Konfigurationsdatei, welche von einer Funktion geparsed wird
                und die ein "Config Objekt" zurückgibt (wie durch
                <classname>Zend_Config</classname>). Mit
                <classname>Zend_Cache_Frontend_File</classname> kann das "Config Objekt" im Cache
                gespeichert werden (um zu Verhindern, das die XML Konfiguration jedes mal geparsed
                wird), aber mit einer strengen Abhängigkeit zur "Masterdatei". Wenn also die XML
                Konfigurationsdatei geändert wird, wird der Cache sofort ungültig.
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.file.options">
            <title>Mögliche Optionen</title>
            <table id="zend.cache.frontends.file.options.table">
                <title>File Frontend Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                          <row>
                              <entry><code>master_File (depreciated)</code></entry>
                              <entry><code>string</code></entry>
                              <entry><code></code></entry>
                              <entry>
                                  Der komplette Pfad und Name der Master Datei
                              </entry>
                          </row>
                          <row>
                              <entry><code>master_files</code></entry>
                              <entry><code>array</code></entry>
                              <entry><code></code></entry>
                              <entry>
                                  Ein Array der kompletten Pfade der Masterdateien
                              </entry>
                          </row>
                          <row>
                              <entry><code>master_files_mode</code></entry>
                              <entry><code>string</code></entry>
                              <entry>
                                  <classname>Zend_Cache_Frontend_File::MODE_OR</classname>
                              </entry>
                              <entry>
                                  <classname>Zend_Cache_Frontend_File::MODE_AND</classname> oder
                                  <classname>Zend_Cache_Frontend_File::MODE_OR</classname> ;
                                  bei <code>MODE_AND</code> müssen alle Masterdateien angegriffen
                                  werden um einen Cache ungültig zu machen, bei <code>MODE_OR</code>
                                  ist eine eizelne angegriffene Datei genug um den Cache ungültig zu
                                  machen
                              </entry>
                          </row>
                          <row>
                              <entry><code>ignore_missing_master_files</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                  bei true werden fehlende Masterdateien leise ignoriert
                                  (andernfalls wird eine Exception geworfen)
                              </entry>
                          </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        <sect3 id="zend.cache.frontends.file.examples">
            <title>Beispiele</title>
            <para>
                Die Verwendung dieses Frontends ist die gleiche wie die von
                <classname>Zend_Cache_Core</classname>. Es gibt kein eigenes Beispiel - was als
                einziges gemacht werden muß, ist das <code>master_File</code> zu definieren, wenn
                die Factory verwendet wird.
            </para>
        </sect3>
    </sect2>

    <sect2 id="zend.cache.frontends.page">
        <title>Zend_Cache_Frontend_Page</title>
        <sect3 id="zend.cache.frontends.page.introduction">
            <title>Einführung</title>
            <para>
                <classname>Zend_Cache_Frontend_Page</classname> ist wie
                <classname>Zend_Cache_Frontend_Output</classname> aber entwickelt für eine komplette
                Seite. Es ist unmöglich <classname>Zend_Cache_Frontend_Page</classname> nur für das
                Cachen eines einzelnen Blockes zu verwenden.
            </para>
            <para>
                Andererseits wird die "Cache ID" automatisch berechnet mit
                <code>$_SERVER['REQUEST_URI']</code> und (abhängig von den Optionen) mit
                <code>$_GET</code>, <code>$_POST</code>, <code>$_SESSION</code>,
                <code>$_COOKIE</code>, <code>$_FILES</code>. Trotzdem muß nur eine Methode
                aufgerufen werden (<code>start()</code>), weil der Aufruf von <code>end()</code>
                immer vollautomatisch ist, wenn die Seite endet.
            </para>
            <para>
                Zur Zeit ist es nicht eingebaut, aber es ist ein HTTP abhängiges System geplant, um
                Bandbreiten zu sparen (das System wird ein "HTTP 304 nicht geändert" schicken, wenn
                der Cache gefunden wurde und wenn der Browser bereits eine gültige Version hat).
            </para>
        </sect3>
        <sect3 id="zend.cache.frontends.page.options">
            <title>Mögliche Optionen</title>
            <table id="zend.cache.frontends.page.options.table">
                <title>Page Frontend Optionen</title>
                <tgroup cols="4">
                     <thead>
                          <row>
                            <entry>Option</entry>
                            <entry>Daten Typ</entry>
                            <entry>Standardwert</entry>
                            <entry>Beschreibung</entry>
                        </row>
                     </thead>
                     <tbody>
                            <row>
                              <entry><code>http_conditional</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                  Verwendung des http_conditional Systems (zur Zeit nicht
                                  implementiert)
                              </entry>
                         </row>
                         <row>
                              <entry><code>debug_header</code></entry>
                              <entry><code>boolean</code></entry>
                              <entry><code>false</code></entry>
                              <entry>
                                    Wenn true, wird eine Debugging Text for jeder gecacheten Seite
                                    hinzugefügt
                              </entry>
                         </row>
                         <row>
                               <entry><code>default_options</code></entry>
                              <entry><code>array</code></entry>
                              <entry><code>array(...siehe unten...)</code></entry>
                              <entry>
                                  Ein assoziatives Array mit Default Optionen:
                                  <itemizedlist>
                                      <listitem>
                                          <para>
                                              <code>(boolean, true per Default) cache</code> :
                                              Cache ist aktiviert wenn true
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, false per Default)
                                              cache_with_get_variables</code> : wenn true, ist der
                                              Cache weiterhin aktiviert, selbst wenn es einige
                                              Variablen im <code>$_GET</code> Array gibt
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, false per Default)
                                              cache_with_post_variables</code> : wenn true, ist der
                                              Cache weiterhin aktiviert, selbst wenn es einige
                                              Variablen im <code>$_POST</code> Array gibt
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, false per Default)
                                              cache_with_session_variables</code> : wenn true, ist
                                              der Cache weiterhin aktiviert, selbst wenn es einige
                                              Variablen im <code>$_SESSION</code> Array gibt
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, false per Default)
                                              cache_with_files_variables</code> : wenn true, ist der
                                              Cache weiterhin aktiviert, selbst wenn es einige
                                              Variablen im <code>$_FILES</code> Array gibt
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, false per Default)
                                              cache_with_cookie_variables</code> : wenn true, ist
                                              der Cache weiterhin aktiviert, selbst wenn es einige
                                              Variablen im <code>$_COOKIE</code> Array gibt
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, true per Default)
                                              make_id_with_get_variables</code> : wenn true, wird
                                              die Cache ID vom Inhalt des <code>$_GET</code> Arrays
                                              abhängig sein
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, true per Default)
                                              make_id_with_post_variables</code> : wenn true, wird
                                              die Cache ID vom Inhalt des <code>$_POST</code> Arrays
                                              abhängig sein
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, true per Default)
                                              make_id_with_session_variables</code> : wenn true,
                                              wird die Cache ID vom Inhalt des
                                              <code>$_SESSION</code> Arrays abhängig sein
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, true per Default)
                                              make_id_with_files_variables</code> : wenn true, wird
                                              die Cache ID vom Inhalt des <code>$_FILES</code>
                                              Arrays abhängig sein
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(boolean, true per Default)
                                              make_id_with_cookie_variables</code> : wenn true, wird
                                              die Cache ID vom Inhalt des <code>$_COOKIE</code>
                                              Arrays abhängig sein
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(int, false by default) specific_lifetime</code>
                                              : wenn nicht false, wird die angegebene Lifetime für
                                              das ausgewählte Regex verwendet
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(array, array() by default) tags</code> : Tags
                                              für den Cache Eintrag
                                          </para>
                                      </listitem>
                                      <listitem>
                                          <para>
                                              <code>(int, null by default) priority</code> :
                                              Priorität (wenn das Backend das unterstützt)
                                          </para>
                                      </listitem>
                                  </itemizedlist>
                              </entry>
                         </row>
                         <row>
                              <entry><code>regexps</code></entry>
                              <entry><code>array</code></entry>
                              <entry><code>array()</code></entry>
                              <entry>
                                    Ein assoziatives Array, um Optionen nur für einige REQUEST_URI
                                    zu setzen. Die Schlüssel sind reguläre Ausdrücke (PCRE), die
                                    Werte sind ein assoziatives Array mit spezifischen Optionen, die
                                    gesetzt werden sollen, wenn der reguläre Ausdruck auf
                                    $_SERVER['REQUEST_URI'] passt (siehe die default_options für
                                    eine Liste der verfügbaren Optionen); wenn verschiedene reguläre
                                    Ausdrücke auf $_SERVER['REQUEST_URI'] passen, wird nur der
                                    letzte verwendet.
                              </entry>
                         </row>
                         <row>
                              <entry><code>memorize_headers</code></entry>
                              <entry><code>array</code></entry>
                              <entry><code>array()</code></entry>
                              <entry>
                                   Ein Array von Strings die zu einem HTTP Headernamen
                                   korrespondieren. Aufgelistete Header werden mit den Cache Daten
                                   gespeichert und wieder "abgespielt" wenn der Cache getroffen
                                   wird.
                              </entry>
                         </row>
                      </tbody>
                  </tgroup>
              </table>
        </sect3>
        <sect3 id="zend.cache.frontends.page.examples">
            <title>Beispiele</title>
            <para>
                Die Verwendung von <classname>Zend_Cache_Frontend_Page</classname> ist wirklich
                trivial :
            </para>
            <programlisting language="php"><![CDATA[
// [...] // Benötigt, Konfiguration und Factory

$cache->start();
// Wenn der Cache gefunden wurde, wird das Ergebnis zum Browser geschickt,
// und das Skript stoppt hier

// Rest der Seite ...
]]></programlisting>
            <para>
                Ein etwas komplexeres Beispiel, welches einen Weg zeigt, um ein zentralisiertes
                Cache Management in einer Bootstrap Datei zu erhalten (um es z.B. mit
                <classname>Zend_Controller</classname> zu verwenden)
            </para>
            <programlisting language="php"><![CDATA[
/*
 * Es sollte vermieden werden, zu viele Zeilen vor dem Cache Bereich zu setzen
 * zum Beispiel sollten für optimale Performanz "require_once" oder
 * "Zend_Loader::loadClass" nach dem Cache Bereich stehen
 */

$frontendOptions = array(
   'lifetime' => 7200,
   'debug_header' => true, // für das Debuggen
   'regexps' => array(
       // cache den gesamten IndexController
       '^/$' => array('cache' => true),

       // cache den gesamten IndexController
       '^/index/' => array('cache' => true),

       // wir cachen nicht den ArticleController...
       '^/article/' => array('cache' => false),

       // ...aber wir cachen die "View" Aktion von diesem ArticleController
       '^/article/view/' => array(
           'cache' => true,

           // und wir cachen sogar wenn es einige Variablen in $_POST gibt
           'cache_with_post_variables' => true,

           // aber die Cache Id wird vom $_POST Array abhängig sein
           'make_id_with_post_variables' => true,
       )
   )
);

$backendOptions = array(
    'cache_dir' => '/tmp/'
);

// erhalte ein Zend_Cache_Frontend_Page Objekt
$cache = Zend_Cache::factory('Page',
                             'File',
                             $frontendOptions,
                             $backendOptions);

$cache->start();

// Wenn der Cache gefunden wurde, wird das Ergebnis zum Browser geschickt,
// und das Skript stoppt hier

// [...] das Ende der Bootstrap Datei
// diese Zeilen werden nicht ausgeführt, wenn der Cache ausgegeben wurde
]]></programlisting>
        </sect3>
        <sect3 id="zend.cache.frontends.page.cancel">
            <title>Die spezielle cancel Methode</title>
            <para>
                Aus Designgründen, kann es in einigen Fällen (zum Beispiel bei Verwendung von nicht
                HTTP/200 Return Codes), notwendig sein den aktuellen Cacheprozess zu unterbrechen.
                Deshalb zeigen wir für dieses spezielle Frontend die cancel() Methode.
            </para>
            <programlisting language="php"><![CDATA[
// [...] // Benötigt, Konfiguration und Factory

$cache->start();

// [...]

if ($someTest) {
    $cache->cancel();
    // [...]
}

// [...]
]]></programlisting>
        </sect3>

    </sect2>

</sect1>
