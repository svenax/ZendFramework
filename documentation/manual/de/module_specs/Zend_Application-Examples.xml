<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 14823 -->
<!-- Reviewed: no -->
<sect1 id="zend.application.examples">
    <title>Beispiele</title>

    <para>
        Die Bootstrap Klasse selbst wird typischerweise sehr minimal sein; oft besteht Sie nur
        aus dem folgenden:
    </para>

    <programlisting role="php"><![CDATA[
class Bootstrap extends Zend_Application_Bootstrap_Base
{
    public function run()
    {
        $this->frontController->dispatch();
    }
}
]]>
    </programlisting>

    <para>
        Mit einer entsprechenden Konfigurationsdatei:
    </para>

    <programlisting role="ini"><![CDATA[
; APPLICATION_PATH/configs/application.ini
[production]
bootstrap.path = APPLICATION_PATH "/Bootstrap.php"
bootstrap.class = "Bootstrap"
resources.frontController.controllerDirectory = APPLICATION_PATH "/controllers"

[development : testing]
[development : production]
]]></programlisting>

    <para>
        Sollten trotzdem, eigene Initialisierungen notwendig sein, hat man zwei Möglichkeiten.
        Erstens, kann man Methoden schreiben die mit <code>_init</code> anfangen um eigenen Code
        zu spezifizieren der für das Bootstrapping verwendet werden soll. Diese Methoden werden
        durch bootstrap( aufgerufen, und können genauso aufgerufen werden wie wenn Sie öffentliche
        Methoden wären: <code>bootstrap&lt;resource&gt;()</code>. Sie sollten ein optionales
        Array an Optionen akzeptieren.
    </para>

    <programlisting role="php"><![CDATA[
class Bootstrap extends Zend_Application_Bootstrap_Base
{
    protected function _initRequest(array $options = array())
    {
        // sicherstellen das eine Front Controller Instanz vorhanden ist
        $this->bootstrap('frontController');
        $this->request = new Zend_Controller_Request_Http();
        $this->frontController->setRequest($this->request);
    }
}
]]>
    </programlisting>

    <para>
        Beachte in diesem Beispiel den Aufruf von <code>bootstrap()</code>; dieser stellt sicher
        das der Front Controlle initialisiert wurde before die Methode aufgerufen wird. Dieser
        Aufruf kan entweder eine Ressource oder eine andere Methode in der Klasse auslösen.
    </para>

    <para>
        Die andere Option ist die Verwendung einer Bootstrap Ressource. Bootstrap Ressourcen sind
        Objekte die spezielle Initialisierungen ausführen, und die wie folgt spezifiziert werden
        können:
    </para>

    <itemizedlist>
        <listitem>
            <para>
                Wärend der Instanzierung des Zend_Application Objekts
            </para>
        </listitem>
        <listitem>
            <para>
                Wärend der Initialisierung des Bootstrap Objekts
            </para>
        </listitem>
        <listitem>
            <para>
                Durch explizites einschalten über Methodenaufrufe auf dem Bootstrap Objekt
            </para>
        </listitem>
    </itemizedlist>

    <para>
        Ressourcen implementieren <code>Zend_Application_Bootstrap_Resource</code>, welche einfach
        definieren das Sie Injektion des Aufrufers und von Optionen erlauben, und die eine
        <code>init()</code> Methode haben. Als Beispiel, könnte eine eigene "View" Bootstrap
        Ressource wie folgt aussehen:
    </para>

    <programlisting role="php"><![CDATA[
class My_Bootstrap_Resource_View extends Zend_Application_Resource_Base
{
    public function init(array $options = array())
    {
        $view = new Zend_View($options);
        Zend_Dojo::enableView($view);

        $view->doctype('XHTML1_STRICT');
        $view->headTitle()->setSeparator(' - ')->append('Meine Site');
        $view->headMeta()->appendHttpEquiv('Content-Type',
                                           'text/html; charset=utf-8');

        $view->dojo()->setDjConfigOption('parseOnLoad', true)
                     ->setLocalPath('/js/dojo/dojo.js')
                     ->registerModulePath('../spindle', 'spindle')
                     ->addStylesheetModule('spindle.themes.spindle')
                     ->requireModule('spindle.main')
                     ->disable();

        $viewRenderer = Zend_Controller_Action_HelperBroker::getStaticHelper(
                            'ViewRenderer'
                        );
        $viewRenderer->setView($view);

        Zend_Registry::set('view', $view);
    }
}
]]>
    </programlisting>

    <para>
        Um der Bootstrap zu sagen das sie das verwenden soll, würde man entweder den Klassennamen
        der Ressource übergeben müssen, oder eine Kombination eines Plugin Loader Präfix Pfades
        und den Kurznamen der Ressource (z.B. "view"):
    </para>

    <programlisting role="php"><![CDATA[
$application = new Zend_Application(
    APPLICATION_ENV,
    array(
        'resources' => array(
            'My_Bootstrap_Resource_View', // kompletter Klassenname; ODER
            'view',                       // Kurzname

            'FrontController' => array(
                'controllerDirectory' => APPLICATION_PATH . '/controllers',
            ),
        ),

        // Für Kurznamen, definiere die Ressourcen Pfade:
        'resourcePaths = array(
            'My_Bootstrap_Resource' => 'My/Bootstrap/Resource',
        )
    )
);
]]>
    </programlisting>

    <para>
        Ressourcen können andere Ressourcen und Initialisierungen aufrufen indem Sie auf das
        Eltern-Objekt zugreifen:
    </para>

    <programlisting role="php"><![CDATA[
class My_Bootstrap_Resource_Layout extends Zend_Application_Resource_Base
{
    public function init(array $options = array())
    {
        // Sicherstellen das die View initialisiert ist...
        $this->getBootstrap()->bootstrap('view');

        // ...
    }
}
]]>
    </programlisting>

    <para>
        Bei normaler Verwendung würde man die Anwendung instanziieren, sie bootstrappen, und
        anschließend ausführen:
    </para>

    <programlisting role="php"><![CDATA[
$application = new Zend_Application(...);
$application->bootstrap();
$application->run();
]]>
    </programlisting>

    <para>
        Für ein eigenes Skript müsste man einfach spezifische Ressourcen initialisieren:
    </para>

    <programlisting role="php"><![CDATA[
$application = new Zend_Application(...);
$application->bootstrap('db');

$service = new Zend_XmlRpc_Server();
$service->setClass('Foo');  // Verwende die Datenbank...
echo $service->handle();
]]>
    </programlisting>

    <para>
        Statt der Verwendung der <code>bootstrap()</code> Methode um interne Methode oder
        Ressourcen aufzurufen, kann man auch Überladung verwenden:
    </para>

    <programlisting role="php"><![CDATA[
$application = new Zend_Application(...);
$application->bootstrapDb();
]]>
    </programlisting>
</sect1>
