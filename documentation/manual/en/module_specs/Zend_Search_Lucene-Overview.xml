<sect1 id="zend.search.lucene.overview">
    <title>Overview</title>

    <sect2 id="zend.search.lucene.introduction">
        <title>Introduction</title>
        <para>Zend_Search_Lucene is a general purpose text search engine written entirely in PHP 5.
            Since it stores its index on the filesystem and does not require a database
            server, it can add search capabilities to almost any PHP-driven website.
            Zend_Search_Lucene supports the following features:<itemizedlist>
                <listitem>
                    <para>Ranked searching - best results returned first</para>
                </listitem>
                <listitem>
                    <para>
                       Many powerful query types: phrase queries, boolean queries, wildcard queries,
                       proximity queries, range queries and many others.
                    </para>
                </listitem>
                <listitem>
                    <para>Search by specific field (e.g., title, author, contents)</para>
                </listitem>
            </itemizedlist>

            Zend_Search_Lucene was derived from the Apache Lucene project.  The currently (starting from ZF 1.6) supported Lucene index format 
            versions are 1.4 - 2.3. For more information on Lucene, visit <ulink url="http://lucene.apache.org/java/docs/"/>.
        </para>
        <note>
            <title/>
            <para>
                Previous Zend_Search_Lucene implementations support the Lucene 1.4 (1.9) - 2.1 index formats. 
            </para>
            <para>
                Starting from ZF 1.5 any index created using pre-2.1 index format is automatically upgraded to Lucene 2.1 format 
                after the Zend_Search_Lucene update and will not be compatible with Zend_Search_Lucene implementations included into ZF 1.0.x.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.search.lucene.index-creation.documents-and-fields">
        <title>Document and Field Objects</title>
            <para>
                Zend_Search_Lucene operates with documents as atomic objects for indexing.  A document is
                divided into named fields, and fields have content that can be searched.
            </para>

            <para>
                A document is represented by the Zend_Search_Lucene_Document class, and this objects of this class contain
                instances of Zend_Search_Lucene_Field that represent the fields on the document.
            </para>

            <para>
                It is important to note that any information can be added to the index.
                Application-specific information or metadata can be stored in the document
                fields, and later retrieved with the document during search.
            </para>

            <para>
                It is the responsibility of your application to control the indexer.
                This means that data can be indexed from any source
                that is accessible by your application.  For example, this could be the
                filesystem, a database, an HTML form, etc.
            </para>

            <para>
                <code>Zend_Search_Lucene_Field</code> class provides several static methods to create fields with
                different characteristics:
            </para>

            <programlisting role="php"><![CDATA[
$doc = new Zend_Search_Lucene_Document();

// Field is not tokenized, but is indexed and stored within the index.
// Stored fields can be retrived from the index.
$doc->addField(Zend_Search_Lucene_Field::Keyword('doctype',
                                                 'autogenerated'));

// Field is not tokenized nor indexed, but is stored in the index.
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('created',
                                                   time()));

// Binary String valued Field that is not tokenized nor indexed,
// but is stored in the index.
$doc->addField(Zend_Search_Lucene_Field::Binary('icon',
                                                $iconData));

// Field is tokenized and indexed, and is stored in the index.
$doc->addField(Zend_Search_Lucene_Field::Text('annotation',
                                              'Document annotation text'));

// Field is tokenized and indexed, but is not stored in the index.
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents',
                                                  'My document content'));
]]>
            </programlisting>

            <para>
                Each of these methods (excluding the <code>Zend_Search_Lucene_Field::Binary()</code> method) has an optional
                <code>$encoding</code> parameter for specifying input data encoding.
            </para>

            <para>
                Encoding may differ for different documents as well as for different fields within one document:

                <programlisting role="php"><![CDATA[
$doc = new Zend_Search_Lucene_Document();
$doc->addField(Zend_Search_Lucene_Field::Text('title',
                                              $title,
                                              'iso-8859-1'));
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents',
                                                  $contents,
                                                  'utf-8'));
]]>
                </programlisting>
            </para>

            <para>
                If encoding parameter is omitted, then the current locale is used at processing time. For example:
                <programlisting role="php"><![CDATA[
setlocale(LC_ALL, 'de_DE.iso-8859-1');
...
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents', $contents));
]]>
                </programlisting>
            </para>

            <para>
                Fields are always stored and returned from the index in UTF-8 encoding. Any required conversion to UTF-8 happens
                automatically.
            </para>

            <para>
                Text analyzers (<link linkend="zend.search.lucene.extending.analysis">see below</link>) may also convert text
                to some other encodings. Actually, the default analyzer converts text to 'ASCII//TRANSLIT' encoding.
                Be careful, however; this translation may depend on current locale.
            </para>

            <para>
                Fields' names are defined at your discretion in the <code>addField()</code> method.
            </para>

            <para>
                Java Lucene uses the 'contents' field as a default field to search.
                Zend_Search_Lucene searches through all fields by default, but the behavior is configurable.
                See the <link linkend="zend.search.lucene.query-language.fields">"Default search field"</link> chapter for details.
            </para>
    </sect2>

    <sect2 id="zend.search.lucene.index-creation.understanding-field-types">
        <title>Understanding Field Types</title>
        <itemizedlist>
            <listitem>
                <para>
                    <code>Keyword</code> fields are stored and indexed, meaning that they can be searched as well
                    as displayed in search results. They are not split up into separate words by tokenization.
                    Enumerated database fields usually translate well to Keyword fields in Zend_Search_Lucene.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>UnIndexed</code> fields are not searchable, but they are returned with search hits.  Database
                    timestamps, primary keys, file system paths, and other external identifiers are good
                    candidates for UnIndexed fields.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>Binary</code> fields are not tokenized or indexed, but are stored for retrieval with search hits.
                    They can be used to store any data encoded as a binary string, such as an image icon.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>Text</code> fields are stored, indexed, and tokenized. Text fields are appropriate for storing
                    information like subjects and titles that need to be searchable as well as returned with
                    search results.
                </para>
            </listitem>
            <listitem>
                <para>
                    <code>UnStored</code> fields are tokenized and indexed, but not stored in the index. Large amounts of
                    text are best indexed using this type of field. Storing data creates a larger index on
                    disk, so if you need to search but not redisplay the data, use an UnStored field.
                    UnStored fields are practical when using a Zend_Search_Lucene index in
                    combination with a relational database. You can index large data fields with UnStored
                    fields for searching, and retrieve them from your relational database by using a separate
                    field as an identifier.
               </para>

                <table id="zend.search.lucene.index-creation.understanding-field-types.table">
                    <title>Zend_Search_Lucene_Field Types</title>
                    <tgroup cols="5">
                        <thead>
                            <row>
                                <entry>Field Type</entry>
                                <entry>Stored</entry>
                                <entry>Indexed</entry>
                                <entry>Tokenized</entry>
                                <entry>Binary</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>Keyword</entry>
                                <entry>Yes</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                                <entry>No</entry>
                            </row>
                            <row>
                                <entry>UnIndexed</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                                <entry>No</entry>
                                <entry>No</entry>
                            </row>
                            <row>
                                <entry>Binary</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                                <entry>No</entry>
                                <entry>Yes</entry>
                            </row>
                            <row>
                                <entry>Text</entry>
                                <entry>Yes</entry>
                                <entry>Yes</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                            </row>
                            <row>
                                <entry>UnStored</entry>
                                <entry>No</entry>
                                <entry>Yes</entry>
                                <entry>Yes</entry>
                                <entry>No</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
           </listitem>
       </itemizedlist>
    </sect2>

    <sect2 id="zend.search.lucene.index-creation.html-documents">
        <title>HTML documents</title>
        <para>
            Zend_Search_Lucene offers a HTML parsing feature. Documents can be created directly from a HTML file or string:
            <programlisting role="php"><![CDATA[
$doc = Zend_Search_Lucene_Document_Html::loadHTMLFile($filename);
$index->addDocument($doc);
...
$doc = Zend_Search_Lucene_Document_Html::loadHTML($htmlString);
$index->addDocument($doc);
]]>
            </programlisting>
        </para>

        <para>
            <code>Zend_Search_Lucene_Document_Html</code> class uses the <code>DOMDocument::loadHTML()</code> and
            <code>DOMDocument::loadHTMLFile()</code> methods to parse the source HTML, so it doesn't need HTML to be well formed or
            to be XHTML. On the other hand, it's sensitive to the encoding specied by the "meta http-equiv" header tag.
        </para>

        <para>
            <code>Zend_Search_Lucene_Document_Html</code> class recognizes document title, body and document header meta tags.
        </para>

        <para>
            The 'title' field is actually the /html/head/title value. It's stored within the index, tokenized and available for search.
        </para>

        <para>
            The 'body' field is the actual body content of the HTML file or string. It doesn't include scripts, comments or attributes.
        </para>

        <para>
            The <code>loadHTML()</code> and <code>loadHTMLFile()</code> methods of <code>Zend_Search_Lucene_Document_Html</code> class
            also have second optional argument. If it's set to true, then body content is also stored within index and can
            be retrieved from the index. By default, the body is tokenized and indexed, but not stored.
        </para>

        <para>
            Other document header meta tags produce additional document fields. The field 'name' is taken from 'name' attribute, and
            the 'content' attribute populates the field 'value'. Both are tokenized, indexed and stored, so documents may be searched by their meta tags
            (for example, by keywords).
        </para>

        <para>
            Parsed documents may be augmented by the programmer with any other field:
            <programlisting role="php"><![CDATA[
$doc = Zend_Search_Lucene_Document_Html::loadHTML($htmlString);
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('created',
                                                   time()));
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('updated',
                                                   time()));
$doc->addField(Zend_Search_Lucene_Field::Text('annotation',
                                              'Document annotation text'));
$index->addDocument($doc);
]]>
            </programlisting>
        </para>

        <para>
            Document links are not included in the generated document, but may be retrieved with
            the <code>Zend_Search_Lucene_Document_Html::getLinks()</code> and <code>Zend_Search_Lucene_Document_Html::getHeaderLinks()</code>
            methods:
            <programlisting role="php"><![CDATA[
$doc = Zend_Search_Lucene_Document_Html::loadHTML($htmlString);
$linksArray = $doc->getLinks();
$headerLinksArray = $doc->getHeaderLinks();
]]>
            </programlisting>
        </para>

        <para>
            Starting from ZF 1.6 it's also possible to exclude links with <code>rel</code> attribute set to <code>'nofollow'</code>.
            Use <code>Zend_Search_Lucene_Document_Html::setExcludeNoFollowLinks($true)</code> to turn on this option.
        </para>
        <para>
            <code>Zend_Search_Lucene_Document_Html::getExcludeNoFollowLinks()</code> method returns current state of 
            "Exclude nofollow links" flag.
        </para>
    </sect2>

</sect1>
