<sect1 id="zend.form.decorators">
    <title>Creating Custom Form Markup Using Zend_Form_Decorator</title>

    <para>
        Rendering a form object is completely optional -- you do not need to use
        <code>Zend_Form</code>'s render() methods at all. However, if you do,
        decorators are used to render the various form objects. 
    </para>

    <para>
        An arbitrary number of decorators may be attached to each item
        (elements, display groups, sub forms, or the form object itself);
        however, only one decorator of a given type may be attached to each
        item.  Decorators are called in the order they are registered. Depending
        on the decorator, it may replace the content passed to it, or append or
        prepend the content.
    </para>

    <para>
        Object state is set via configuration options passed to the constructor
        or the decorator's <code>setOptions()</code> method. When creating
        decorators via an item's <code>addDecorator()</code> or related methods,
        options may be passed as an argument to the method. These can be used to
        specify placement, a separator to use between passed in content and
        newly generated content, and whatever options the decorator supports.
    </para>

    <para>
        Before each decorator's <code>render()</code> method is called, the
        current item is set in the decorator using <code>setElement()</code>,
        giving the decorator awareness of the item being rendered. This allows
        you to create decorators that only render specific portions of the item
        -- such as the label, the value, error messages, etc. By stringing
        together several decorators that render specific element segments, you
        can build complex markup representing the entire item.
    </para>

    <sect2 id="zend.form.decorators.operation">
        <title>Operation</title>

        <para>
            To configure a decorator, pass an array of options or a
            <code>Zend_Config</code> object to its constructor, an array to
            <code>setOptions()</code>, or a <code>Zend_Config</code> object to
            <code>setConfig()</code>.
        </para>

        <para>
            Standard options include:
        </para>

        <itemizedlist>
            <listitem><para>
                    <code>placement</code>: Placement can be either 'append' or
                    'prepend' (case insensitive), and indicates whether content
                    passed to <code>render()</code> will be appended or
                    prepended, respectively. In the case that a decorator
                    replaces the content, this setting is ignored. The default
                    setting is to append.
            </para></listitem>

            <listitem><para>
                    <code>separator</code>: The separator is used between the
                    content passed to <code>render()</code> and new content
                    generated by the decorator, or between items rendered by the
                    decorator (e.g. FormElements uses the separator between each
                    item rendered). In the case that a decorator replaces the
                    content, this setting may be ignored. The default value is
                    <code>PHP_EOL</code>.
            </para></listitem>
        </itemizedlist>

        <para>
            The decorator interface specifies methods for interacting with
            options. These include:
        </para>

        <itemizedlist>
            <listitem><para>
                    <code>setOption($key, $value)</code>: set a single option.
            </para></listitem>

            <listitem><para>
                    <code>getOption($key)</code>: retrieve a single option
                    value.
            </para></listitem>

            <listitem><para>
                    <code>getOptions()</code>: retrieve all options.
            </para></listitem>

            <listitem><para>
                    <code>removeOption($key)</code>: remove a single option.
            </para></listitem>

            <listitem><para>
                    <code>clearOptions()</code>: remove all options.
            </para></listitem>
        </itemizedlist>

        <para>
            Decorators are meant to interact with the various
            <code>Zend_Form</code> class types: <code>Zend_Form</code>,
            <code>Zend_Form_Element</code>, <code>Zend_Form_DisplayGroup</code>,
            and all classes deriving from them. The method
            <code>setElement()</code> allows you to set the object the
            decorator is currently working with, and <code>getElement()</code>
            is used to retrieve it.
        </para>

        <para>
            Each decorator's <code>render()</code> method accepts a string,
            <code>$content</code>. When the first decorator is called, this
            string is typically empty, while on subsequent calls it will be
            populated. Based on the type of decorator and the options passed in,
            the decorator will either replace this string, prepend the string,
            or append the string; an optional separator will be used in the
            latter two situations.
        </para>
    </sect2>

    <sect2 id="zend.form.decorators.standard">
        <title>Standard Decorators</title>

        <para>
            <code>Zend_Form</code> ships with many standard decorators; see
            <link linkend="zend.form.standardDecorators">the chapter on Standard
            Decorators</link> for details.
        </para>
    </sect2>

    <sect2 id="zend.form.decorators.custom">
        <title>Custom Decorators</title>

        <para>
            If you find your rendering needs are complex or need heavy
            customization, you should consider creating a custom decorator.
        </para>

        <para>
            Decorators need only implement
            <code>Zend_Decorator_Interface</code>. The interface specifies the
            following:
        </para>

        <programlisting role="php"><![CDATA[<?php
interface Zend_Decorator_Interface
{
    public function __construct($options = null);
    public function setElement($element);
    public function getElement();
    public function setOptions(array $options);
    public function setConfig(Zend_Config $config);
    public function setOption($key, $value);
    public function getOption($key);
    public function getOptions();
    public function removeOption($key);
    public function clearOptions();
    public function render($content);
}
?>]]></programlisting>

        <para>
            To make this simpler, you can simply extend
            <code>Zend_Decorator_Abstract</code>, which implements all methods
            except <code>render()</code>. 
        </para>

        <para>
            As an example, let's say you wanted to reduce the number of
            decorators you use, and build a "composite" decorator that took care
            of rendering the label, element, any error messages, and description
            in an HTML <code>div</code>. You might build such a 'Composite'
            decorator as follows:
        </para>

        <programlisting role="php"><![CDATA[<?php
class My_Decorator_Composite extends Zend_Form_Decorator_Abstract
{
    public function buildLabel()
    {
        $element = $this->getElement();
        $label = $element->getLabel();
        if ($translator = $element->getTranslator()) {
            $label = $translator->translate($label);
        }
        if ($element->isRequired()) {
            $label .= '*';
        }
        $label .= ':';
        return $element->getView()->formLabel($element->getName(), $label);
    }

    public function buildInput()
    {
        $element = $this->getElement();
        $helper  = $element->helper;
        return $element->getView()->$helper(
            $element->getName(),
            $element->getValue(),
            $element->getAttribs(),
            $element->options
        );
    }

    public function buildErrors()
    {
        $element  = $this->getElement();
        $messages = $element->getMessages();
        if (empty($messages)) {
            return '';
        }
        return '<div class="errors">' . $element->getView()->formErrors($messages) . '</div>';
    }

    public function buildDescription()
    {
        $element = $this->getElement();
        $desc    = $element->getDescription();
        if (empty($desc)) {
            return '';
        }
        return '<div class="description">' . $desc . '</div>';
    }

    public function render($content)
    {
        $element = $this->getElement();
        if (!$element instanceof Zend_Form_Element) {
            return $content;
        }
        if (null === $element->getView()) {
            return $content;
        }

        $separator = $this->getSeparator();
        $placement = $this->getPlacement();
        $label     = $this->buildLabel();
        $input     = $this->buildInput();
        $errors    = $this->buildErrors();
        $desc      = $this->buildDescription();

        $output = '<div class="form element">'
                . $label
                . $input
                . $errors
                . $desc
                . '</div>'

        switch ($placement) {
            case (self::PREPEND):
                return $output . $separator . $content;
            case (self::APPEND):
            default:
                return $content . $separator . $output;
        }
    }
}
?>]]></programlisting>

        <para>
            You can then place this in the decorator path:
        </para>

        <programlisting role="php"><![CDATA[<?php
// for an element:
$element->addPrefixPath('My_Decorator', 'My/Decorator/', 'decorator');

// for all elements:
$form->addElementPrefixPath('My_Decorator', 'My/Decorator/', 'decorator');
?>]]></programlisting>

        <para>
            You can then specify this decorator as 'Composite' and attach it to
            an element:
        </para>

        <programlisting role="php"><![CDATA[<?php
// Overwrite existing decorators with this single one:
$element->setDecorators(array('Composite'));
?>]]></programlisting>

        <para>
            While this example showed how to create a decorator that renders
            complex output from several element properties, you can also create
            decorators that handle a single aspect of an element; the
            'Decorator' and 'Label' decorators are excellent examples of this
            practice. Doing so allows you to mix and match decorators to achieve
            complex output -- and also override single aspects of decoration to
            customize for your needs.
        </para>

        <para>
            For example, if you wanted to simply display that an error occurred
            when validating an element, but not display each of the individual
            validation error messages, you might create your own 'Errors'
            decorator:
        </para>

        <programlisting role="php"><![CDATA[<?php
class My_Decorator_Errors
{
    public function render($content = '')
    {
        $output = '<div class="errors">The value you provided was invalid;
            please try again</div>';

        $placement = $this->getPlacement();
        $separator = $this->getSeparator();

        switch ($placement) {
            case 'PREPEND':
                return $output . $separator . $content;
            case 'APPEND':
            default:
                return $content . $separator . $output;
        }
    }
}
?>]]></programlisting>
    
        <para>
            In this particular example, because the decorator's final segment,
            'Errors', matches the same as <code>Zend_Form_Decorator_Errors</code>,
            it will be rendered <emphasis>in place of</emphasis> that decorator
            -- meaning you would not need to change any decorators to modify the
            output. By naming your decorators after existing standard
            decorators, you can modify decoration without needing to modify your
            elements' decorators.
        </para>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
