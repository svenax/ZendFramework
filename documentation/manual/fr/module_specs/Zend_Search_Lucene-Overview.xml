<sect1 id="zend.search.lucene.overview">
    <title>Vue d'ensemble</title>

    <sect2 id="zend.search.lucene.introduction">
        <title>Introduction</title>
        <para>Zend_Search_Lucene est un moteur de recherche de contenus principalement textuels écrit entièrement en PHP 5.
            Comme il stocke ses index sur le système de fichiers et qu'il ne requiert pas
            de base de données, il peut offrir des fonctionnalités de recherche à presque
            n'importe quel site écrit en PHP.
            Zend_Search_Lucene dispose des caractéristiques suivantes :
            <itemizedlist>
                <listitem>
                    <para>"Ranked searching" - les meilleurs résultats sont retournés en premier.</para>
                </listitem>
                <listitem>
                    <para>
                       Plusieurs puissants types de requêtes : phrase, booléen,
                       astérisque, proximité, intervalle et bien d'autres.
                    </para>
                </listitem>
                <listitem>
                    <para>Recherche par champ spécifique (p. ex. titre, auteur, contenus)</para>
                </listitem>
            </itemizedlist>

            Zend_Search_Lucene est dérivé du projet Apache Lucene. Les versions actuelles de format
            d'index Lucene supportées (à partir du ZF 1.6) sont 1.4 à 2.3. Pour plus d'informations
            sur Lucene, rendez-vous sur <ulink url="http://lucene.apache.org/java/docs/"/>.
        </para>
        <note>
            <title/>
            <para>
                Les implémentations précédentes de Zend_Search_Lucene supportent les formats
                d'indexation Lucene 1.4 (1.9) à 2.1.
            </para>
            <para>
                A partir du Zend Framework 1.5, tout index créé en utilisant une version antérieure à la 2.1 et automatiquement
                mis à niveau au format Lucene 2.1 après la mise à jour de Zend_Search_Lucene et ne sera pas compatible avec les
                implémentations de Zend_Search_Lucene incluses dans le ZF 1.0.x.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.search.lucene.index-creation.documents-and-fields">
        <title>Document and Field Objects</title>
            <para>
                Zend_Search_Lucene travaille avec des documents comme objets de base pour l'indexation. Un
                document est divisé en champs possédant un nom et du contenu dans lequel on pourra chercher.
            </para>

            <para>
                Un document est représenté par la classe Zend_Search_Lucene_Document. Les objets de cette classe
                contiennent des instances de Zend_Search_Lucene_Field qui représentent les champs du document.
            </para>

            <para>
                Il est important de noter que n'importe quelle information peut être ajoutée à l'index.
                Des informations propres à l'application ou des métadonnées peuvent être stockées dans
                le document, puis récupérées durant la recherche.
            </para>

            <para>
                Il est de la responsabilité de votre application de gérer l'indexation.
                Cela signifie que les données peuvent être indexées depuis n'importe quelle
                source accessible par votre application. Par exemple, elles peuvent provenir
                du système de fichier, d'une base de données, d'un formulaire HTML, etc.
            </para>

            <para>
                La classe <code>Zend_Search_Lucene_Field</code> fournit plusieurs méthodes
                statiques pour créer des champs avec différentes caractéristiques :
            </para>

            <programlisting role="php"><![CDATA[
$doc = new Zend_Search_Lucene_Document();

// Le champ n'est pas "tokenizé", mais il est indexé et stocké dans l'index.
// Les champs stockés peuvent être récupéré depuis l'index.
$doc->addField(Zend_Search_Lucene_Field::Keyword('doctype',
                                                 'autogenerated'));

// Le champ n'est ni "tokenizé", ni indexé, mais il est stocké dans l'index.
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('created',
                                                   time()));

// Un champ chaîne binaire qui n'est ni "tokenizé", ni indexé, mais
// stocké dans l'index.
$doc->addField(Zend_Search_Lucene_Field::Binary('icon',
                                                $iconData));

// Un champ "tokenizé", indexé et stocké dans l'index.
$doc->addField(Zend_Search_Lucene_Field::Text('annotation',
                                              'Document annotation text'));

// Un champ "tokenizé" et indexé, mais pas stocké dans l'index.
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents',
                                                  'My document content'));
]]>
            </programlisting>

            <para>
                Chacune de ces méthodes (à l'exception de <code>Zend_Search_Lucene_Field::Binary()</code>) possède
                un paramètre optionnel <code>$encoding</code> servant à spécifier l'encodage de la chaîne entrée.
            </para>

            <para>
                L'encodage peut différer par document, voire par champ au sein d'un même document :

                <programlisting role="php"><![CDATA[
$doc = new Zend_Search_Lucene_Document();
$doc->addField(Zend_Search_Lucene_Field::Text('title',
                                              $title,
                                              'iso-8859-1'));
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents',
                                                  $contents,
                                                  'utf-8'));
]]>
                </programlisting>
            </para>

            <para>
                Si le paramètre d'encodage est omis, la locale courante est alors utilisée pour le déterminer à l'exécution.
                Par exemple :
                <programlisting role="php"><![CDATA[
setlocale(LC_ALL, 'de_DE.iso-8859-1');
...
$doc->addField(Zend_Search_Lucene_Field::UnStored('contents', $contents));
]]>
                </programlisting>
            </para>

            <para>
                Les champs sont toujours stockés et retournés depuis l'index en UTF-8. Toute conversion requise vers UTF-8
                est effectuée automatiquement.
            </para>

            <para>
                Les analyseurs de texte (<link linkend="zend.search.lucene.extending.analysis">voir plus bas</link>) peuvent
                également convertir du texte vers d'autres encodages. Actuellement, l'analyseur par défaut convertit le texte
                au format 'ASCII/TRANSLIT'.
                Soyez prudent, cependant; cette conversion peut déprendre de la locale.
            </para>

            <para>
                Le nom des champs est défini par vous dans la méthode <code>addField()</code>.
            </para>

            <para>
                Java Lucene utilise le champ 'contents' comme champ de recherche par défaut.
                Zend_Search_Lucene cherche par défaut dans tous les champs. Cela dit, ce comportement
                est configurable. Consultez le chapitre <link linkend="zend.search.lucene.query-language.fields">"Champ de recherche par défaut"</link>
                pour plus de détails.
            </para>
    </sect2>

    <sect2 id="zend.search.lucene.index-creation.understanding-field-types">
        <title>Comprendre les types de champs</title>
        <itemizedlist>
            <listitem>
                <para>
                    Les champs <code>Keyword</code> (mot-clé) sont stockés ET indexés. Cela signifie
                    qu'ils peuvent être aussi bien cherchés dans l'index qu'affichés dans les
                    résultats de la recherche. Ils ne sont pas divisés en plusieurs mots par "tokenization".
                    Les champs d'énumérations dans une base de donnée se transposent généralement assez bien
                    en champs de type Keyword dans Zend_Search_Lucene.
                </para>
            </listitem>
            <listitem>
                <para>
                    Les champs <code>UnIndexed</code> (non-indexé) ne peuvent pas être utilisés dans la recherche.
                    En revenche, ils peuvent être retournés dans les résultats. Des timestamps de base de données,
                    des clés primaires, des chemins de fichiers et d'autres identifiants externes sont autant de
                    bons exemples d'utilisation des champs de type UnIndexed.
                </para>
            </listitem>
            <listitem>
                <para>
                    Les champs <code>Binary</code> (binaire) ne sont ni "tokenizés", ni indexés, mais ils sont stockés dans
                    le but d'être retournés dans les résultats de recherche. Ils peuvent être utilisés pour stocker
                    n'importe quelle donnée encodée en chaîne binaire, telle qu'une icône par exemple.
                </para>
            </listitem>
            <listitem>
                <para>
                    Les champs <code>Text</code> (texte) sont stockés, indexés et "tokenizés". Les champs de type Text
                    sont appropriés pour stocker des informations telles que sujets et titres sur lesquels on veut pouvoir
                    effectuer des recherches, mais également les utiliser dans l'affichage des résultats.
                </para>
            </listitem>
            <listitem>
                <para>
                    Les champs <code>UnStored</code> sont "tokenizés" et indexés, mais pas stockés dans l'index. Il
                    est recommandé d'utiliser ce type de champ pour indexer les textes conséquents. Stocker des données
                    implique la création d'index plus volumineux sur le disque. Donc si vous disposez de données sur
                    lesquelles vous voulez uniquement effectuer des recherches sans nécessairement afficher ces données
                    dans les résultats, utilisez un champ de type UnStored.
                    Le type UnStored est pratique lorsque vous utilisez un index Zend_Search_Lucene en combinaison
                    avec une base de données relationnelle. Vous pouvez indexer des gros champs de données dans
                    des champs de type UnStored et les extraire de la base de données relationnelle en utilisant
                    un champ séparé en tant qu'identifiant.
               </para>

                <table id="zend.search.lucene.index-creation.understanding-field-types.table">
                    <title>Les types Zend_Search_Lucene_Field</title>
                    <tgroup cols="5">
                        <thead>
                            <row>
                                <entry>Type de champ</entry>
                                <entry>Stocké</entry>
                                <entry>Indexé</entry>
                                <entry>"Tokenizé"</entry>
                                <entry>Binaire</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>Keyword</entry>
                                <entry>Oui</entry>
                                <entry>Oui</entry>
                                <entry>Non</entry>
                                <entry>Non</entry>
                            </row>
                            <row>
                                <entry>UnIndexed</entry>
                                <entry>Oui</entry>
                                <entry>Non</entry>
                                <entry>Non</entry>
                                <entry>Non</entry>
                            </row>
                            <row>
                                <entry>Binary</entry>
                                <entry>Oui</entry>
                                <entry>Non</entry>
                                <entry>Non</entry>
                                <entry>Oui</entry>
                            </row>
                            <row>
                                <entry>Text</entry>
                                <entry>Oui</entry>
                                <entry>Oui</entry>
                                <entry>Oui</entry>
                                <entry>Non</entry>
                            </row>
                            <row>
                                <entry>UnStored</entry>
                                <entry>Non</entry>
                                <entry>Oui</entry>
                                <entry>Oui</entry>
                                <entry>Non</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
           </listitem>
       </itemizedlist>
    </sect2>

    <sect2 id="zend.search.lucene.index-creation.html-documents">
        <title>Documents HTML</title>
        <para>
            Zend_Search_Lucene offre une fonctionnalité de parsage HTML. Les documents
            peuvent être créés directement à d'un fichier ou d'une chaîne HTML :
            <programlisting role="php"><![CDATA[
$doc = Zend_Search_Lucene_Document_Html::loadHTMLFile($filename);
$index->addDocument($doc);
...
$doc = Zend_Search_Lucene_Document_Html::loadHTML($htmlString);
$index->addDocument($doc);
]]>
            </programlisting>
        </para>

        <para>
            La classe <code>Zend_Search_Lucene_Document_Html</code> utilise les méthodes
            <code>DOMDocument::loadHTML()</code> et <code>DOMDocument::loadHTMLFile()</code>
            pour parser la source HTML, ainsi il n'est pas nécessaire que le HTML soit bien
            formé ou au format XHTML. Par contre, ces méthodes prennent en compte l'encodage
            spécifié dans la balise meta "http-equiv".
        </para>

        <para>
            La classe <code>Zend_Search_Lucene_Document_Html</code> reconnaît le titre d'une
            page HTML, son body, ainsi les métadonnées de son entête.
        </para>

        <para>
            Le champ 'title' correspond au contenu de la balise /html/head/title.
            Il est stocké dans l'index, "tokenizé" et disponible pour la recherche.
        </para>

        <para>
            Le champ 'body' correspond au contenu de la balise 'body' du fichier ou
            de la chaîne HTML. Il ne prend pas en compte les scripts, les commentaires
            ou les attributs.
        </para>

        <para>
            Les méthodes <code>loadHTML()</code> et <code>loadHTMLFile()</code> de la
            classe <code>Zend_Search_Lucene_Document_Html</code> possèdent également
            un deuxième argument optionnel. Si sa valeur est true, le body sera alors
            stocké dans l'index et pourra être retourné dans les résultats de recherche.
            Par défaut, le body est "tokenizé", indexé, mais pas stocké.
        </para>

        <para>
            Les autres metatags génèrent des champs additionnels dans le document. Le
            champ 'name' prend sa valeur dans l'attribut 'name' du metatag. Le champ
            'value' prend sa valeur dans l'attribut 'content' du metatag. Ces deux
            champs sont "tokenizés", indexés et stockés. Ainsi les documents peuvent
            être cherchés à travers leur metadonnées (p. ex. par mots-clés).
        </para>

        <para>
            Les documents parsés peuvent être enrichis par le programmeur avec
            d'autres champs :
            <programlisting role="php"><![CDATA[
$doc = Zend_Search_Lucene_Document_Html::loadHTML($htmlString);
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('created',
                                                   time()));
$doc->addField(Zend_Search_Lucene_Field::UnIndexed('updated',
                                                   time()));
$doc->addField(Zend_Search_Lucene_Field::Text('annotation',
                                              'Document annotation text'));
$index->addDocument($doc);
]]>
            </programlisting>
        </para>

        <para>
            Les liens des documents ne sont pas inclus dans le document généré, mais ils peuvent
            être récupérés avec les méthodes <code>Zend_Search_Lucene_Document_Html::getLinks()</code>
            et <code>Zend_Search_Lucene_Document_Html::getHeaderLinks()</code> :
            <programlisting role="php"><![CDATA[
$doc = Zend_Search_Lucene_Document_Html::loadHTML($htmlString);
$linksArray = $doc->getLinks();
$headerLinksArray = $doc->getHeaderLinks();
]]>
            </programlisting>
        </para>

        <para>
            A partir du ZF 1.6, il est également possible d'exclure les balises 'link' dont
            l'attribut <code>rel</code> vaut <code>'nofollow'</code>. Utilisez
            <code>Zend_Search_Lucene_Document_Html::setExcludeNoFollowLinks($true)</code> pour
            activer cette option.
        </para>
        <para>
            La méthode <code>Zend_Search_Lucene_Document_Html::getExcludeNoFollowLinks()</code>
            retourne la valeur courante du flag "Exclude nofollow links".
        </para>
    </sect2>

    <sect2 id="zend.search.lucene.index-creation.docx-documents">
        <title>Word 2007 documents</title>
        <para>
            Zend_Search_Lucene offers a Word 2007 parsing feature. Documents can be created directly from a Word 2007 file:
            <programlisting role="php"><![CDATA[
$doc = Zend_Search_Lucene_Document_Docx::loadDocxFile($filename);
$index->addDocument($doc);
]]>
            </programlisting>
        </para>

        <para>
            <code>Zend_Search_Lucene_Document_Docx</code> class uses the <code>ZipArchive</code> class and
            <code>simplexml</code> methods to parse the source document. If the <code>ZipArchive</code> class (from module php_zip)
            is not available, the <code>Zend_Search_Lucene_Document_Docx</code> will also not be available for use with Zend Framework.
        </para>

        <para>
            <code>Zend_Search_Lucene_Document_Docx</code> class recognizes document meta data and document text. Meta data consists, depending on document contents, of filename, title, subject, creator, keywords, description, lastModifiedBy, revision, modified, created.
        </para>

        <para>
            The 'filename' field is the actual Word 2007 file name.
        </para>

        <para>
            The 'title' field is the actual document title.
        </para>

        <para>
            The 'subject' field is the actual document subject.
        </para>

        <para>
            The 'creator' field is the actual document creator.
        </para>

        <para>
            The 'keywords' field contains the actual document keywords.
        </para>

        <para>
            The 'description' field is the actual document description.
        </para>

        <para>
            The 'lastModifiedBy' field is the username who has last modified the actual document.
        </para>

        <para>
            The 'revision' field is the actual document revision number.
        </para>

        <para>
            The 'modified' field is the actual document last modified date / time.
        </para>

        <para>
            The 'created' field is the actual document creation date / time.
        </para>

        <para>
            The 'body' field is the actual body content of the Word 2007 document. It only includes normal text, comments and revisions are not included.
        </para>

        <para>
            The <code>loadDocxFile()</code> methods of <code>Zend_Search_Lucene_Document_Docx</code> class
            also have second optional argument. If it's set to true, then body content is also stored within index and can
            be retrieved from the index. By default, the body is tokenized and indexed, but not stored.
        </para>
    
        <para>
            Parsed documents may be augmented by the programmer with any other field:
            <programlisting role="php"><![CDATA[
$doc = Zend_Search_Lucene_Document_Docx::loadDocxFile($filename);
$doc->addField(Zend_Search_Lucene_Field::UnIndexed(
    'indexTime',
    time())
);
$doc->addField(Zend_Search_Lucene_Field::Text(
    'annotation',
    'Document annotation text')
);
$index->addDocument($doc);
]]>
            </programlisting>
        </para>

    </sect2>

    <sect2 id="zend.search.lucene.index-creation.pptx-documents">
        <title>Powerpoint 2007 documents</title>
        <para>
            Zend_Search_Lucene offers a Powerpoint 2007 parsing feature. Documents can be created directly from a Powerpoint 2007 file:
            <programlisting role="php"><![CDATA[
$doc = Zend_Search_Lucene_Document_Pptx::loadPptxFile($filename);
$index->addDocument($doc);
]]>
            </programlisting>
        </para>

        <para>
            <code>Zend_Search_Lucene_Document_Pptx</code> class uses the <code>ZipArchive</code> class and
            <code>simplexml</code> methods to parse the source document. If the <code>ZipArchive</code> class (from module php_zip)
            is not available, the <code>Zend_Search_Lucene_Document_Pptx</code> will also not be available for use with Zend Framework.
        </para>

        <para>
            <code>Zend_Search_Lucene_Document_Pptx</code> class recognizes document meta data and document text. Meta data consists, depending on document contents, of filename, title, subject, creator, keywords, description, lastModifiedBy, revision, modified, created.
        </para>

        <para>
            The 'filename' field is the actual Powerpoint 2007 file name.
        </para>

        <para>
            The 'title' field is the actual document title.
        </para>

        <para>
            The 'subject' field is the actual document subject.
        </para>

        <para>
            The 'creator' field is the actual document creator.
        </para>

        <para>
            The 'keywords' field contains the actual document keywords.
        </para>

        <para>
            The 'description' field is the actual document description.
        </para>

        <para>
            The 'lastModifiedBy' field is the username who has last modified the actual document.
        </para>

        <para>
            The 'revision' field is the actual document revision number.
        </para>

        <para>
            The 'modified' field is the actual document last modified date / time.
        </para>

        <para>
            The 'created' field is the actual document creation date / time.
        </para>

        <para>
            The 'body' field is the actual content of all slides and slide notes in the Powerpoint 2007 document.
        </para>

        <para>
            The <code>loadPptxFile()</code> methods of <code>Zend_Search_Lucene_Document_Pptx</code> class
            also have second optional argument. If it's set to true, then body content is also stored within index and can
            be retrieved from the index. By default, the body is tokenized and indexed, but not stored.
        </para>

        <para>
            Parsed documents may be augmented by the programmer with any other field:
            <programlisting role="php"><![CDATA[
$doc = Zend_Search_Lucene_Document_Pptx::loadPptxFile($filename);
$doc->addField(Zend_Search_Lucene_Field::UnIndexed(
    'indexTime',
    time()));
$doc->addField(Zend_Search_Lucene_Field::Text(
    'annotation',
    'Document annotation text'));
$index->addDocument($doc);
]]>
            </programlisting>
        </para>
    </sect2>

    <sect2 id="zend.search.lucene.index-creation.xlsx-documents">
        <title>Excel 2007 documents</title>
        <para>
            Zend_Search_Lucene offers a Excel 2007 parsing feature. Documents can be created directly from a Excel 2007 file:
            <programlisting role="php"><![CDATA[
$doc = Zend_Search_Lucene_Document_Xlsx::loadXlsxFile($filename);
$index->addDocument($doc);
]]>
            </programlisting>
        </para>

        <para>
            <code>Zend_Search_Lucene_Document_Xlsx</code> class uses the <code>ZipArchive</code> class and
            <code>simplexml</code> methods to parse the source document. If the <code>ZipArchive</code> class (from module php_zip)
            is not available, the <code>Zend_Search_Lucene_Document_Xlsx</code> will also not be available for use with Zend Framework.
        </para>

        <para>
            <code>Zend_Search_Lucene_Document_Xlsx</code> class recognizes document meta data and document text. Meta data consists, depending on document contents, of filename, title, subject, creator, keywords, description, lastModifiedBy, revision, modified, created.
        </para>

        <para>
            The 'filename' field is the actual Excel 2007 file name.
        </para>

        <para>
            The 'title' field is the actual document title.
        </para>

        <para>
            The 'subject' field is the actual document subject.
        </para>

        <para>
            The 'creator' field is the actual document creator.
        </para>

        <para>
            The 'keywords' field contains the actual document keywords.
        </para>

        <para>
            The 'description' field is the actual document description.
        </para>

        <para>
            The 'lastModifiedBy' field is the username who has last modified the actual document.
        </para>

        <para>
            The 'revision' field is the actual document revision number.
        </para>

        <para>
            The 'modified' field is the actual document last modified date / time.
        </para>

        <para>
            The 'created' field is the actual document creation date / time.
        </para>

        <para>
            The 'body' field is the actual content of all cells in all worksheets of the Excel 2007 document.
        </para>

        <para>
            The <code>loadXlsxFile()</code> methods of <code>Zend_Search_Lucene_Document_Xlsx</code> class
            also have second optional argument. If it's set to true, then body content is also stored within index and can
            be retrieved from the index. By default, the body is tokenized and indexed, but not stored.
        </para>

        <para>
            Parsed documents may be augmented by the programmer with any other field:
            <programlisting role="php"><![CDATA[
$doc = Zend_Search_Lucene_Document_Xlsx::loadXlsxFile($filename);
$doc->addField(Zend_Search_Lucene_Field::UnIndexed(
    'indexTime',
    time()));
$doc->addField(Zend_Search_Lucene_Field::Text(
    'annotation',
    'Document annotation text'));
$index->addDocument($doc);
]]>
            </programlisting>
        </para>
    </sect2>
</sect1>
