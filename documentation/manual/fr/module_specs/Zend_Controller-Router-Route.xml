<!-- EN-Revision: 10189 -->
<sect3 id="zend.controller.router.routes.standard">
    <title>Zend_Controller_Router_Route</title>

    <para><code>Zend_Controller_Router_Route</code> est la route par défaut intégrée dans le routeur de réécriture
    (RewriteRouter). Ce routeur combine les deux avantages que sont la simplicité d'utilisation et la flexibilité.
    Chaque route est définie par une correspondance d'URL, statique ou dynamique, et des valeurs par défaut peuvent être
    fournies, de même que des valeurs obligatoires.</para>

    <para>Imaginons une application ayant besoin de posséder une page en décrivant l'auteur. Nous voulons que lorsque le
    navigateur pointe vers <code>http://domaine.fr/auteur/martel</code>, la page d'informations en question puisse
    apparaître, au sujet de "martel". La route pour une telle URL pourrait être :</para>

    <programlisting role="php"><![CDATA[$route = new Zend_Controller_Router_Route(
    'auteur/:username',
    array(
        'controller' => 'profile',
        'action'     => 'userinfo'
    )
);

$router->addRoute('user', $route);]]></programlisting>

    <para>Le premier paramètre du constructeur de <code>Zend_Controller_Router_Route</code> est la définition de la
    route à analyser avec l'URL. Les définitions des routes sont des parties statiques et dynamiques, séparées par des
    slashs ("/"). Les parties statiques sont juste du texte brut : <code>auteur</code>. Les dynamiques, appelées
    variables, sont repérées grâce à un caractère deux-points (:) devant la variable : <code>:username</code>.</para>

    <note>
        <title>Utilisation des caractères</title>

        <para>Pour identifier une variable dans un schéma de routage (après le deux-points), en théorie n'importe quel
        caractère fait l'affaire (sauf le slash "/"). Cependant il est conseillé de n'utiliser que des caractères que
        PHP comprend comme étant des noms de variables valides. Les implémentations futures de ce comportement peuvent
        changer, altérant ainsi votre code.</para>
    </note>

    <para>Cette route exemple devrait être utilisée lorsque le navigateur pointe vers
    <code>http://domaine.fr/auteur/martel</code>, et dans un tel cas, tous les paramètres de la requête seront injectés
    dans l'objet <code>Zend_Controller_Request</code> et seront accessibles à travers votre
    <code>ProfileController</code>. Les variables retournées par cet exemple peuvent être représentées par le tableau
    suivant :</para>

    <programlisting role="php"><![CDATA[$values = array(
    'username'   => 'martel',
    'controller' => 'profile',
    'action'     => 'userinfo'
);]]></programlisting>

    <para>Plus tard, <code>Zend_Controller_Dispatcher_Standard</code> va dispatcher vers la méthode
    <code>userinfoAction()</code> de <code>ProfileController</code> (dans le module par défaut) selon ces valeurs. A cet
    endroit, il sera possible d'accéder à toutes les variables de la requête grâce à
    <code>Zend_Controller_Action::_getParam()</code> ou <code>Zend_Controller_Request::getParam()</code> :</para>

    <programlisting role="php"><![CDATA[public function userinfoAction()
{
    $request = $this->getRequest();
    $username = $request->getParam('username');

    $username = $this->_getParam('username');
}]]></programlisting>

    <para>La définition des routes peut contenir un ou plusieurs caractères spéciaux - des jokers - représentés par le
    symbole '*'. Il est utilisé pour collecter des paramètres. L'exemple suivant représente plus ou moins le
    comportement par défaut de la route "Module" :</para>

    <programlisting role="php"><![CDATA[$route = new Zend_Controller_Router_Route(
    ':module/:controller/:action/*',
    array('module' => 'default')
);
$router->addRoute('default', $route);]]></programlisting>

    <sect4 id="zend.controller.router.routes.standard.variable-defaults">
        <title>Variables par défaut</title>

        <para>Chaque variable dynamique dans la définition des routes peut avoir une valeur par défaut. C'est à cela que
        sert le second paramètre du constructeur de <code>Zend_Controller_Router_Route</code>. Il s'agit d'un tableau
        avec comme clés les noms des variables, et comme valeurs, leurs valeurs par défaut :</para>

        <programlisting role="php"><![CDATA[$route = new Zend_Controller_Router_Route(
    'archive/:annee',
    array('annee' => 2006)
);
$router->addRoute('archive', $route);]]></programlisting>

        <para>L'exemple ci-dessus établira une correspondance avec les URL comme
        <code>http://domaine.fr/archive/2005</code> et <code>http://exemple.fr/archive</code>. Dans ce dernier cas, la
        variable de l'année (<code>annee</code>) aura la valeur 2006.</para>

        <para>L'exemple ci-dessus injecte ainsi un paramètre représentant une année (<code>annee</code>). Si aucune
        information de contrôleur ou d'actions n'est présente, alors ceux par défaut seront utilisés (ils sont définis
        dans <code>Zend_Controller_Dispatcher_Abstract</code>). Pour que l'exemple soit plus intuitif, spécifions des
        contrôleur/action par défaut dans notre route :</para>

        <programlisting role="php"><![CDATA[$route = new Zend_Controller_Router_Route(
    'archive/:annee',
    array(
        'annee'       => 2006,
        'controller' => 'archive',
        'action'     => 'show'
    )
);
$router->addRoute('archive', $route);]]></programlisting>

        <para>Cette route va alors donner un dispatching vers la méthode <code>showAction()</code> de
        <code>ArchiveController</code>.</para>
    </sect4>

    <sect4 id="zend.controller.router.routes.standard.variable-requirements">
        <title>Obligations et contraintes des variables</title>

        <para>Vous pouvez ajouter un troisième paramètre au constructeur de <code>Zend_Controller_Router_Route</code>
        pour spécifier une variable obligatoire. Ceci s'effectue au moyen d'expressions régulières :</para>

        <programlisting role="php"><![CDATA[$route = new Zend_Controller_Router_Route(
    'archive/:annee',
    array(
        'annee'       => 2006,
        'controller' => 'archive',
        'action'     => 'show'
    ),
    array('year' => '\d+')
);
$router->addRoute('archive', $route);]]></programlisting>

        <para>Avec une telle définition de route, comme ci-dessus, le routeur n'établira une correspondance que si la
        variable "<code>annee</code>" contient une donnée numérique : <code>http://domaine.fr/archive/2345</code>. Une
        URL comme <code>http://exemple.annee/archive/test</code> ne sera pas captée (matchée) par cette route, et le
        contrôle sera passé à la route suivante, etc.</para>
    </sect4>

    <sect4 id="zend.controller.router.routes.standard.hostname-routing">
        <title>Routage par le nom d'hôte</title>

        <para>Vous pouvez aussi utiliser le nom d'hôte ("Hostname") pour la correspondance de route. Pour une simple
        correspondance, il existe une option de nom d'hôte statique :</para>

        <programlisting role="php"><![CDATA[$route = new Zend_Controller_Router_Route(
    array(
        'host' => 'blog.monsite.fr',
        'path' => 'archive'
    ),
    array(
        'module'     => 'blog',
        'controller' => 'archive',
        'action'     => 'index'
    )
);
$router->addRoute('archive', $route);]]></programlisting>

        <para>i vous voulez capter des paramètres dans le nom d'hôte, il existe une option de type expression régulière.
        Dans l'exemple suivant, le sous-domaine est utilisé en tant que paramètre de nom d'utilisateur pour le
        contrôleur d'action. Quand vous assemblez la route, vous fournissez simplement le nom d'utilisateur en tant que
        paramètre, comme vous le feriez avec tout autre paramètre :</para>

        <programlisting role="php"><![CDATA[$route = new Zend_Controller_Router_Route(
    array(
        'host' => array(
            'regex'   => '([a-z]+).monsite.fr',
            'reverse' => '%s.monsite.fr'
            'params'  => array(
                1 => 'username'
            ) 
        ),
        'path' => ''
    ),
    array(
        'module'     => 'users',
        'controller' => 'profile',
        'action'     => 'index'
    )
);
$router->addRoute('profile', $route);]]></programlisting>
    </sect4>
</sect3>