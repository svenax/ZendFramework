<!-- EN-Revision: 13277 -->
<sect1 id="zend.validate.set" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Classes de validation standard</title>

    <para>Le Zend Framework est fourni avec un jeu de classes de validation standard, qui sont directement utilisables
    par votre application.</para>

    <sect2 id="zend.validate.set.alnum">
        <title>Alnum</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> contient seulement des caractères
        alphabétiques et numériques. Ce validateur inclue une option permettant la validation possible des caractères
        espace.</para>
    </sect2>

    <sect2 id="zend.validate.set.alpha">
        <title>Alpha</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> contient seulement des caractères
        alphabétiques. Ce validateur inclue une option permettant la validation possible des caractères espace.</para>

        <note>
            <para>Les caractères alphabétiques comprennent les caractères destinés à constituer des mots dans chaque
            langue. Cependant l'alphabet anglais est aussi utilisé pour les langues suivantes : chinois, japonais et
            coréen. La langue est spécifiée par <code>Zend_Locale</code>.</para>
        </note>
    </sect2>

    <sect2 id="zend.validate.set.barcode">
        <title>Barcode</title>

        <para>Ce validateur est intancié avec le type de code-barres suivant lequel vous souhaitez valider une valeur.
        Il supporte actuellement les types de code-barres "<code>UPC-A</code>" (Universal Product Code) et
        "<code>EAN-13</code>" (European Article Number), et la méthode <code>isValid()</code> retourne <code>true</code>
        si et seulement si la valeur fournie est validée par l'algorithme de validation du code-barres. Vous devez
        retirer tous les caractères exceptés les nombres compris entre zéro et neuf (0-9) de la valeur à tester avant de
        la fournir au validateur.</para>
    </sect2>

    <sect2 id="zend.validate.set.between">
        <title>Between</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> est compris entre les valeurs minimum et
        maximum définies. La comparaison inclue par défaut les bornes (<code>$value</code> peut égaler le minimum ou le
        maximum), bien que ceci puisse être surchargé pour avoir une comparaison stricte, où <code>$value</code> doit
        être strictement supérieur au minimum et strictement inférieur au maximum.</para>
    </sect2>

    <sect2 id="zend.validate.set.ccnum">
        <title>Ccnum</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> respecte <ulink
        url="http://fr.wikipedia.org/wiki/Luhn">l'algorithme de Luhn ("module 10")</ulink> pour les numéros de cartes de
        crédits.</para>
    </sect2>

    <sect2 id="zend.validate.set.date">
        <title>Date</title>

        <para>Retourne <code>true</code> si <code>$value</code> est une date valide au format <code>YYYY-MM-DD</code>.
        Si l'option <code>locale</code> est fournie alors la date sera validé suivant le paramètre local. Enfin si
        l'option <code>format</code> est fournie ce format est utilisé pour la validation. Pour plus de détails
        concernant les paramètres optionnel, referez vous à <link
        linkend="zend.date.others.comparison.table">Zend_Date::isDate()</link>.</para>
    </sect2>

    <sect2 id="zend.validate.set.digits">
        <title>Digits</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> contient seulement des caractères
        numériques.</para>
    </sect2>

    <!-- EN-Revision: 13277 -->

    <sect2 id="zend.validate.set.email_address">
        <title>EmailAddress</title>

        <para><code>Zend_Validate_EmailAddress</code> permet de valider une adresse émail. Ce validateur éclate d'abord
        l'adresse émail entre partie locale et domaine et essaie de valider ces deux parties conformément aux
        spécifications des adresses émail et des noms de domaine.</para>

        <para>
            <emphasis role="strong">Utilisation de base</emphasis>
        </para>

        <para>Exemple basique : <programlisting role="php"><![CDATA[
$validateur = new Zend_Validate_EmailAddress();
if ($validateur->isValid($email)) {
    // l'email est valide
} else {
    // l'email est invalide ; afficher pourquoi
    foreach ($validateur->getMessages() as $message) {
        echo "$message\n";
    }
}
]]></programlisting> Ceci validera l'adresse émail <code>$email</code> et, en cas d'échec, fournira des messages
        d'erreur informatifs via <code>$validator-&gt;getMessages()</code>.</para>

        <para>
            <emphasis role="strong">Parties locales complexes</emphasis>
        </para>

        <para><code>Zend_Validate_EmailAddress</code> validera toute adresse émail conforme à la RFC2822. Comme par
        exemple <code>bob@domaine.com</code>, <code>bob+jones@domaine.fr</code>, <code>"bob@jones"@domaine.com</code> et
        <code>"bob jones"@domaine.com</code>. Quelques formats d'émail obsolètes ne seront pas validés (comme tout émail
        contenant un retour chariot ou un caractère "\").</para>

        <para>
            <emphasis role="strong">Validation de différents types de noms de domaine</emphasis>
        </para>

        <para>La partie domaine d'une adresse émail est validée via <link linkend="zend.validate.set.hostname">
                <code>Zend_Validate_Hostname</code>
            </link>. Par défaut, seules les domaines qualifiés sous la forme <code>domaine.com</code> sont acceptés,
        même si, il vous est possible d'accepter les adresses IP et les domaines locaux également.</para>

        <para>Afin de réaliser cette opération, il vous faut instancier <code>Zend_Validate_EmailAddress</code> en lui
        passant un paramètre indiquant le type de nom de domaine à accepter. Les détails sont disponibles dans
        <code>Zend_Validate_EmailAddress</code> mais vous trouverez ci-dessous un exemple illustrant comment accepter
        les noms de domaines qualifiés et les hôtes locaux : <programlisting role="php"><![CDATA[
$validateur = new Zend_Validate_EmailAddress(Zend_Validate_Hostname::ALLOW_DNS | Zend_Validate_Hostname::ALLOW_LOCAL);
if ($validateur->isValid($email)) {
    // l'email est valide
} else {
    // l'email est invalide ; afficher pourquoi
    foreach ($validateur->getMessages() as $message) {
        echo "$message\n";
    }
}
]]></programlisting></para>

        <para>
            <emphasis role="strong">Vérification que le nom de domaine accepte réellement l'émail</emphasis>
        </para>

        <para>Le fait qu'une adresse électronique est dans un format correct, ne signifie pas nécessairement que
        l'adresse électronique existe en réalité. Pour aider résoudre ce problème, vous pouvez utiliser la validation MX
        pour vérifier si une entrée MX (l'émail) existe dans le l'enregistrement du DNS pour le nom de domaine de
        l'émail. Cela vous dit que le nom de domaine accepte l'émail, mais ne vous dit pas que l'adresse électronique
        elle-même est valable.</para>

        <para>La vérification MX n'est pas active par défaut et est seulement supporté par des plates-formes UNIX pour
        l'instant. Pour activer la vérification MX vous pouvez passer un deuxième paramètre au constructeur
        <code>Zend_Validate_EmailAddress</code>. <programlisting role="php"><![CDATA[
$validator =
    new Zend_Validate_EmailAddress(Zend_Validate_Hostname::ALLOW_DNS,
                                   true);
]]></programlisting> Alternativement vous pouvez passer soit <code>true</code> soit <code>false</code> à
        <code>$validator-&gt;setValidateMx()</code> pour activer ou désactiver la validation MX.</para>

        <para>En activant ce paramètre, les fonctions de réseau seront utilisés pour vérifier la présence d'un
        enregistrement MX sur le nom de domaine de l'adresse électronique que vous voulez valider. Faîtes cependant
        attention, cela ralentira probablement votre scénario.</para>

        <para>
            <emphasis role="strong">Valider les noms de domaines internationaux</emphasis>
        </para>

        <para><code>Zend_Validate_EmailAddress</code> peut aussi vérifier les caractères internationaux qui existent
        dans quelques domaines. Ceci est connu comme le support de Nom de Domaine International (IDN). Celui-ci est
        activé par défaut, quoique vous puissiez le mettre hors service en changeant le paramètre via l'objet interne
        <code>Zend_Validate_Hostname</code> qui existe dans <code>Zend_Validate_EmailAddress</code>. <programlisting
        role="php"><![CDATA[
$validator->hostnameValidator->setValidateIdn(false);
]]></programlisting> De plus amples informations concernant l'utilisation de <code>setValidateIdn()</code> sont
        présentes dans la <link linkend="zend.validate.set.hostname">documentation de
        <code>Zend_Validate_Hostname</code></link>.</para>

        <para>Notez cependant que les IDNs sont seulement validés si vous autorisez la validation des nom de
        domaines.</para>

        <para>
            <emphasis role="strong">Validation des "Top Level Domains"</emphasis>
        </para>

        <para>Par défaut un nom de domaine sera vérifié grâce à une liste de TLDs connus. Ceci est activé par défaut,
        quoique vous puissiez le mettre hors service en changeant le paramètre via l'objet
        <code>Zend_Validate_Hostname</code> interne qui existe dans <code>Zend_Validate_EmailAddress</code>.
        <programlisting role="php"><![CDATA[
$validator->hostnameValidator->setValidateTld(false);
]]></programlisting> De plus amples informations concernant l'utilisation de <code>setValidateTld()</code> sont
        présentes dans la <link linkend="zend.validate.set.hostname">documentation de
        <code>Zend_Validate_Hostname</code></link>.</para>

        <para>Notez cependant que les TLDs sont seulement validés si vous autorisez la validation des nom de
        domaines.</para>
    </sect2>

    <sect2 id="zend.validate.set.float">
        <title>Float</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> est une valeur en virgule
        flottante.</para>
    </sect2>

    <sect2 id="zend.validate.set.greater_than">
        <title>GreaterThan</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> est supérieure à une valeur minimum
        fournie.</para>
    </sect2>

    <sect2 id="zend.validate.set.hex">
        <title>Hex</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> contient seulement des caractères
        numériques hexadécimaux.</para>
    </sect2>

    <!-- EN-Revision: 13277 -->

    <sect2 id="zend.validate.set.hostname">
        <title>Hostname</title>

        <para><code>Zend_Validate_Hostname</code> vous permet de valider un nom de domaine sur la base d'un ensemble de
        spécifications connues. Il est ainsi possible de valider trois types différents de noms de domaine : un nom de
        domaine qualifié (ex : domaine.com), une adresse IP (ex : 1.2.3.4) ou un nom de domaine local (ex : localhost).
        Par défaut, seul les noms de domaine qualifiés sont acceptés.</para>

        <para>
            <emphasis role="strong">Utilisation basique</emphasis>
        </para>

        <para>Exemple simple : <programlisting role="php"><![CDATA[
$validateur = new Zend_Validate_Hostname();
if ($validateur->isValid($domaine)) {
    // le nom de domaine est valide
} else {
    // le nom de domaine est invalide ; afficher pourquoi
    foreach ($validateur->getMessages() as $message) {
        echo "$message\n";
    }
}
]]></programlisting> Ceci validera le domaine <code>$domaine</code> et, en cas d'échec, fournira des messages d'erreur
        informatifs via <code>$validator-&gt;getMessages()</code>.</para>

        <para>
            <emphasis role="strong">Validation de différents types de noms de domaine</emphasis>
        </para>

        <para>Il peut se trouver que vous souhaitez valider des adresses IP, des noms de domaine locaux ou toute
        combinaison de tous les types disponibles. Cette opération peut être effectuée en passant un paramètre à
        <code>Zend_Validate_Hostname</code> au moment de l'instanciation. Le paramètre doit être un entier qui détermine
        quels types de noms de domaine sont admis. Il est recommandé d'utiliser les constantes de la classe
        <code>Zend_Validate_Hostname</code>.</para>

        <para>Les constantes de <code>Zend_Validate_Hostname</code> sont : <code>ALLOW_DNS</code> qui autorise
        uniquement les noms de domaine qualifiés, <code>ALLOW_IP</code> qui autorise les adresses IP,
        <code>ALLOW_LOCAL</code> qui autorise les domaines locaux et <code>ALLOW_ALL</code> qui autorise les trois types
        précédents. Pour vérifier uniquement les adresses IP, vous pouvez utiliser l'exemple suivant : <programlisting
        role="php"><![CDATA[
$validateur = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_IP);
if ($validateur->isValid($hostname)) {
    // le nom de domaine est valide
} else {
    // le nom de domaine est invalide ; afficher pourquoi
    foreach ($validateur->getMessages() as $message) {
        echo "$message\n";
    }
}
]]></programlisting></para>

        <para>Vous pouvez utiliser <code>ALLOW_ALL</code> pour accepter tous les types de domaines. De même, vous pouvez
        créer des configurations combinant ces différents types. Par exemple, pour accepter les domaines qualifiés et
        les domaines locaux, instanciez votre objet <code>Zend_Validate_Hostname</code> de la manière suivante :
        <programlisting role="php"><![CDATA[
$validateur = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_DNS |
                                         Zend_Validate_Hostname::ALLOW_IP);
]]></programlisting></para>

        <para>
            <emphasis role="strong">Validation de Nom de Domaine International (IDN)</emphasis>
        </para>

        <para>Certains noms de domaines nationaux (Country Code Top Level Domains ou ccTLD), comme .de (Allemagne),
        supporte les caractères internationaux dans leurs noms de domaine. Ceci est connu sous le nom de Nom de Domaine
        International (IDN). Ces domaines peuvent être vérifiés par <code>Zend_Validate_Hostname</code> grâce aux
        caractères étendus qui sont utilisés dans le processus de validation.</para>

        <para>Pour l'instant, la liste des ccTLD supportés inclus : <itemizedlist>
                <listitem>
                    <para>at (Autriche)</para>
                </listitem>

                <listitem>
                    <para>ch (Suisse)</para>
                </listitem>

                <listitem>
                    <para>li (Liechtenstein)</para>
                </listitem>

                <listitem>
                    <para>de (Allemagne)</para>
                </listitem>

                <listitem>
                    <para>fi (Finlande)</para>
                </listitem>

                <listitem>
                    <para>hu (Hongrie)</para>
                </listitem>

                <listitem>
                    <para>no (Norvège)</para>
                </listitem>

                <listitem>
                    <para>se (Suède)</para>
                </listitem>
            </itemizedlist></para>

        <para>Pour vérifier un domaine IDN c'est aussi simple que d'utiliser le validateur standard de nom de domaine
        puisque la validation IDN est activé par défaut. Si vous voulez mettre hors service la validation IDN, cela peut
        être fait par le passage d'un paramètre au constructeur <code>Zend_Validate_Hostname</code> ou via la méthode
        <code>$validator-&gt;setValidateIdn()</code>.</para>

        <para>Vous pouvez aussi désactiver la validation IDN en passant un second paramètre au constructeur du
        <code>Zend_Validate_Hostname</code> comme ceci : <programlisting role="php"><![CDATA[
$validator = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_DNS,
                                        false);
]]></programlisting> Alternativement vous pouvez passer soit <code>true</code> soit <code>false</code> à
        <code>$validator-&gt;setValidateIdn()</code> pour activer ou désactiver la validation IDN. Si vous essayez de
        vérifier un nom de domaine IDN qui n'est pas actuellement soutenu il est probable qu'il retournera une erreur
        s'il y a des caractères internationaux. Quand un fichier de ccTLD spécifiant les caractères supplémentaires
        n'existe pas dans "Zend/Validate/Hostname",une validation de nom de domaine normale est réalisée.</para>

        <para>Notez cependant que les IDNs sont seulement validés si vous autorisez la validation des noms de
        domaine.</para>

        <para>
            <emphasis role="strong">Validation des "Top Level Domains"</emphasis>
        </para>

        <para>Par défaut un nom de domaine sera vérifié grâce à une liste de TLDs connus. Si cette fonctionnalité n'est
        pas nécessaire, elle peut être désactivée de la même façon que la désactivation du support des IDNs. Vous pouvez
        désactiver la validation TLD en passant un troisième paramètre au constructeur de
        <code>Zend_Validate_Hostname</code>. Dans l'exemple ci-dessous, la validation IDN est supportée via le second
        paramètre. <programlisting role="php"><![CDATA[
$validator = new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_DNS,
                                        true,
                                        false);
]]></programlisting> Alternativement vous pouvez passer soit <code>true</code> soit <code>false</code> à
        <code>$validator-&gt;setValidateTld()</code> pour activer ou désactiver la validation TLD.</para>

        <para>Notez cependant que les TLDs sont seulement validés si vous autorisez la validation des noms de
        domaine.</para>
    </sect2>

    <sect2 id="zend.validate.set.in_array">
        <title>InArray</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> est contenue dans un tableau. Si
        l'option stricte est à <code>true</code>, alors le type de <code>$value</code> est aussi vérifié.</para>
    </sect2>

    <sect2 id="zend.validate.set.int">
        <title>Int</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> est une valeur entière.</para>
    </sect2>

    <sect2 id="zend.validate.set.ip">
        <title>Ip</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> est une adresse IP valide.</para>
    </sect2>

    <sect2 id="zend.validate.set.less_than">
        <title>LessThan</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> est inférieure à une valeur maximum
        fournie.</para>
    </sect2>

    <sect2 id="zend.validate.set.not_empty">
        <title>NotEmpty</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> est une valeur non vide.</para>
    </sect2>

    <sect2 id="zend.validate.set.regex">
        <title>Regex</title>

        <para>Retourne <code>true</code> si et seulement si <code>$value</code> respecte une expression régulière
        fournie.</para>
    </sect2>

    <sect2 id="zend.validate.set.string_length">
        <title>StringLength</title>

        <para>Retourne <code>true</code> si et seulement si la longueur de la chaîne <code>$value</code> est supérieure
        à une valeur minimum et inférieure à une valeur maximum (quand l'option max n'est pas à <code>null</code>). La
        méthode <code>setMin()</code> lève une exception si la valeur fournie pour la longueur minimum est supérieure à
        celle fournie pour la longueur maximum, et la méthode <code>setMax()</code> lève une exception si la valeur
        fournie pour la longueur maximum est supérieure à celle fournie pour la longueur minimum. Cette classe supporte
        l'UTF-8 et les autres encodages, en se basant sur la valeur courante de <ulink
                url="http://www.php.net/manual/fr/ref.iconv.php#iconv.configuration">
                <code>iconv.internal_encoding</code>
            </ulink>. Si vous avez besoin de régler un autre encodage, vous pouvez le faire avec les accesseurs
        <code>getEncoding()</code> et <code>setEncoding()</code>.</para>
    </sect2>
</sect1>