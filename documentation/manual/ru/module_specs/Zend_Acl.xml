<sect1 id="zend.acl.introduction">
    <title>Введение</title>

    <para>
        Zend_Acl предоставляет легковесный и гибкий набор функциональных
        возможностей списка прав доступа (ACL) и управления привилегиями.
        Приложение может использовать этот функционал для контроля доступа одних
        объектов к другим - защищенным.
    </para>

    <para>
        В рамках данной документации,
        <itemizedlist>
            <listitem>
                <para>
                    <emphasis role="strong">Ресурс</emphasis> - объект, доступ к
                    которому контролируется.
                </para>
            </listitem>
            <listitem>
                <para>
                    <emphasis role="strong">Роль</emphasis> - объект, который
                    может запросить доступ к Ресурсу.
                </para>
            </listitem>
        </itemizedlist>
        
        Говоря проще, <emphasis role="strong">Роли запрашивают доступ к
        Ресурсу</emphasis>.
        Например, если человек запрашивает доступ к автомобилю, тогда
        человек - это Роль, а автомобиль - Ресурс,
        поскольку доступ к автомобилю находится под контролем.
    </para>

    <para>
        Благодаря спецификации и использованию списка прав доступа(ACL),
        приложение получает контроль над тем, как запрашивающие объекты (роли)
        получают доступ к защищенным объектам (ресурсам).
    </para>

    <sect2 id="zend.acl.introduction.resources">
        <title>О ресурсах</title>
        <para>
            В Zend_Acl создать ресурс очень просто. Zend_Acl предоставляет
            <code>Zend_Acl_Resource_Interface</code>, чтобы облегчить
            разработчикам процесс создания ресурса. Класс должен только
            реализовать этот интерфейс, который состоит из одного метода,
            <code>getResourceId()</code>, для того, чтобы Zend_Acl рассматривал
            объект как ресурс. Дополнительно, Zend_Acl также содержит
            <code>Zend_Acl_Resource</code>, как базовый класс, который
            разработчики могут расширять по желанию.
        </para>
        <para>
            Zend_Acl предусматривает структуру в виде дерева, в которое могут
            добавляться многочисленные ресурсы (или "подконтрольные зоны"). Так
            как ресурсы добавлены в такую структуру, они могут быть организованы
            от общих (корень дерева) к специфическим (листья дерева).
            При запросах к определенным ресурсам в иерархии будет выполнен
            автоматический поиск правил, относящихся к ресурсам-предкам,
            учитывающий простое наследование правил. Например, если некое общее
            правило должно действовать в каждом здании города, то проще
            прикрепить его к городу, нежели крепить к каждому зданию в городе.
            Однако, для некоторых зданий потребуются исключения из этого
            правила, в Zend_Acl это достигается путем
            закрепления исключений из правила за каждым зданием, которое
            нуждается в этом.
            Ресурс может наследоваться только от одного родительского ресурса,
            однако сам родительский ресурс может,
            в свою очередь, наследоваться от своего родительского ресурса и т.д.
        </para>
        <para>
            Zend_Acl также поддерживает права доступа к ресурсам (например,
            "создание", "чтение", "обновление", "удаление"), и
            разработчик может закреплять правила, которые будут влиять на все
            или определенные права доступа к ресурсу.
        </para>
    </sect2>

    <sect2 id="zend.acl.introduction.roles">
        <title>О ролях</title>
        <para>
            Как и в случае с ресурсами, создавать роль также очень просто.
            Zend_Acl предоставляет <code>Zend_Acl_Role_Interface</code>, чтобы
            облегчить разработчикам процесс создания ролей. Класс должен только
            реализовать этот интерфейс, который состоит из одного метода,
            <code>getRoleId()</code>, для того, чтобы Zend_Acl рассматривал
            объект как роль. Дополнительно, Zend_Acl также содержит
            <code>Zend_Acl_Role</code>, как базовый класс, который разработчики
            могут расширять по желанию.
        </para>
        <para>
            В Zend_Acl роль может наследоваться от одной или от нескольких
            ролей. Это реализовано для поддержки
            наследования правил между ролями. Например, пользовательская роль,
            такая как "Салли", может принадлежать одной или нескольким
            родительским ролям, таким как "редактор" и "администратор".
            Разработчик может привязывать правила к "редактору" и
            "администратору" раздельно, и "Салли" будет наследовать правила
            обоих ролей. Нет необходимости привязывать правила непосредственно
            к "Салли".
        </para>
        <para>
            Хотя множественное наследование ролей - очень полезная возможность,
            она также усложняет разработку. Следующий пример демонстрирует
            неопределенное условие и показывает как Zend_Acl решает эту
            проблему.
        </para>
        <example id="zend.acl.introduction.roles.example.multiple_inheritance">
            <title>Множественное наследование ролей</title>
            <para>
                Следующий код определяет три базовые роли  -
                "<code>guest</code>", "<code>member</code>", и
                "<code>admin</code>" - от которых другие роли будут
                наследоваться. Затем, роль "<code>someUser</code>" создается и
                наследуется от трех других ролей. Порядок,
                в котором эти роли появляются в массиве <code>$parents</code>,
                важен. При необходимости Zend_Acl ищет правила доступа не
                только для запрашиваемых ролей (в нашем случае,
                "<code>someUser</code>"), но также и для ролей, от которых
                запрашиваемая роль унаследована
                (в нашем примере, "<code>guest</code>", "<code>member</code>", и
                "<code>admin</code>"):
            </para>
            <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Acl.php';
$acl = new Zend_Acl();

require_once 'Zend/Acl/Role.php';
$acl->addRole(new Zend_Acl_Role('guest'))
    ->addRole(new Zend_Acl_Role('member'))
    ->addRole(new Zend_Acl_Role('admin'));

$parents = array('guest', 'member', 'admin');
$acl->addRole(new Zend_Acl_Role('someUser'), $parents);

require_once 'Zend/Acl/Resource.php';
$acl->add(new Zend_Acl_Resource('someResource'));

$acl->deny('guest', 'someResource');
$acl->allow('member', 'someResource');

echo $acl->isAllowed('someUser', 'someResource') ? 'allowed' : 'denied';]]>
            </programlisting>
            <para>
                Поскольку нет правил, определенных специально для роли
                "<code>someUser</code>" и ресурса
                "<code>someResource</code>", то Zend_Acl должен производить
                поиск правил, которые могут быть определены для ролей,
                от которых "<code>someUser</code>" наследуется. Сперва
                проверяется роль "<code>admin</code>", и
                для нее не определены правила доступа. Затем проверяется роль
                "<code>member</code>", и Zend_Acl обнаруживает, что есть правило
                разрешающее доступ для "<code>member</code>" к
                "<code>someResource</code>".
            </para>
            <para>
                Если бы Zend_Acl продолжил поиск правил, определенных для
                родительских ролей, то он обнаружил бы, что для
                "<code>guest</code>" запрещен доступ к
                "<code>someResource</code>". Это пример показывает противоречие,
                так как теперь для "<code>someUser</code>" доступ к
                "<code>someResource</code>" разрешен и запрещен одновременно.
                Конфликт произошел по причине наследования от нескольких ролей.
            </para>
            <para>
                Zend_Acl решает эту неоднозначность, завершая запрос, как только
                находит первое правило, которое может быть применено к запросу.
                В этом случае, если роль "<code>member</code>"
                проверяется раньше, чем роль "<code>guest</code>", то
                данный пример выведет "<code>allowed</code>".
            </para>
        </example>
        <note>
            <para>
                Когда определяется нескольких родительских ролей, то не
                забывайте, что последний указанный родитель
                будет первым в списке поиска правил для запроса авторизации.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.acl.introduction.creating">
        <title>Создание списка контроля доступа (ACL)</title>

        <para>
            ACL может представлять любое множество физических или виртуальных
            объектов. В целях демонстрации, мы создадим базовый функционал
            ACL для системы управления контентом (CMS),
            который будет поддерживать нескольких уровней групп к множеству
            областей. Чтобы создать новый объект ACL, производим инстанцирование
            без параметров:
        </para>

        <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Acl.php';

$acl = new Zend_Acl();]]>
        </programlisting>

        <note>
            <para>
                До тех пор, пока разработчик не определит какое-либо правило,
                разрешающее доступ, Zend_Acl отказывает всем ролям в доступе ко
                всем привилегиям на все ресурсы.
            </para>
        </note>
    </sect2>

    <sect2 id="zend.acl.introduction.role_registry">
        <title>Регистрация ролей</title>

        <para>
            Системы управления контентом почти всегда нуждаются в иерархии
            доступа для определения авторских возможностей своих пользователей.
            Это может быть группа "Гость",
            предоставляющая ограниченный доступ для демонстрации, группа
            "Сотрудник" - группа большинства пользователей CMS,
            которые производят каждодневные операции, группа "Редактор" - для
            тех кто публикует и редактирует, архивирует и удаляет контент, и,
            наконец, группа "Администратор", участники которой могут выполнять
            все операции, которые доступны участникам других групп, а также
            управлять закрытой информацией, пользователями,
            конфигурировать адинистративной части, а также делать резервное
            копирование/восстановление данных.
            Этот набор прав доступа может быть представлен в реестре ролей,
            позволяя каждой группе наследовать привилегии
            родительской группы, при этом имея индивидуальные права доступа.
            Права доступа могут быть изображены в следующем виде:
        </para>

        <table id="zend.acl.introduction.role_registry.table.example_cms_access_controls">
          <title>Контроль за доступом для демонстрационной CMS</title>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Название</entry>
                <entry>Индивидуальные права</entry>
                <entry>Права, унаследованные от</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Гость</entry>
                <entry>Просмотр</entry>
                <entry>Не определено</entry>
              </row>
              <row>
                <entry>Сотрудник</entry>
                <entry>Редактирование, предложение на публикацию, исправление</entry>
                <entry>Гость</entry>
              </row>
              <row>
                <entry>Редактор</entry>
                <entry>Публикация, архивирование, удаление</entry>
                <entry>Сотрудник</entry>
              </row>
              <row>
                <entry>Администратор</entry>
                <entry>(Обладает всеми правами)</entry>
                <entry>Не определено</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>
            Для этого примера мы используем <code>Zend_Acl_Role</code>, но можно
            было бы использовать любой класс,
            который реализует интерфейс <code>Zend_Acl_Role_Interface</code>.
            Эти группы могут быть добавлены в реестр ролей
            следующим образом:
        </para>

        <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Acl.php';

$acl = new Zend_Acl();

//Добавить группы в реестр Ролей используя Zend_Acl_Role
require_once 'Zend/Acl/Role.php';

// Гость не наследует управление доступом
$roleGuest = new Zend_Acl_Role('guest');
$acl->addRole($roleGuest);

//Сотрудник наследуется от Гостя
$acl->addRole(new Zend_Acl_Role('staff'), $roleGuest);

/*
Альтернатива тому, что написано выше:
$acl->addRole(new Zend_Acl_Role('staff'), 'guest');
//*/

//Редактор наледуется от Посетителя
$acl->addRole(new Zend_Acl_Role('editor'), 'staff');

//Администатор не наследует управление доступом
$acl->addRole(new Zend_Acl_Role('administrator'));]]>
        </programlisting>

    </sect2>

    <sect2 id="zend.acl.introduction.defining">
        <title>Определение контроля доступа</title>

        <para>
            Теперь, когда ACL содержит все необходимые роли, можно определить
            правила, по которым роли будут иметь доступ к ресурсам. Вы, должно
            быть, заметили, что мы не определили ни одного отдельного ресурса
            для этого примера, это упрощает демонстрацию того, что правила
            применяются ко всем ресурсам. Zend_Acl предоставляет реализацию,
            посредством которой правила должны передаваться
            от общих к специфическим, минимизируя таким образом количество
            необходимых правил, так как
            ресурсы и роли наследуют правила, которые определены для их предков.
        </para>

        <para>
            В результате мы можем определить умеренно сложный набор правил
            минимальным кодом. Чтобы определить базовые права доступа, описанные
            выше:
        </para>

        <programlisting role="php"><![CDATA[<?php
require_once 'Zend/Acl.php';

$acl = new Zend_Acl();

require_once 'Zend/Acl/Role.php';

$roleGuest = new Zend_Acl_Role('guest');
$acl->addRole($roleGuest);
$acl->addRole(new Zend_Acl_Role('staff'), $roleGuest);
$acl->addRole(new Zend_Acl_Role('editor'), 'staff');
$acl->addRole(new Zend_Acl_Role('administrator'));

// Гость может только просматривать контент
$acl->allow($roleGuest, null, 'view');

/* другим способом, предыдущий блок кода может быть записан в таком виде:
$acl->allow('guest', null, 'view');
//*/

// Сотрудник наследует привилегии просмотра у Гостя, но также нуждается в дополнительных привилегиях
$acl->allow('staff', null, array('edit', 'submit', 'revise'));

// Редактор наследует привилегии просмотра, редактирования, отправки и исправлений у Посетителя
// но также нуждается в дополнительных привилегиях
$acl->allow('editor', null, array('publish', 'archive', 'delete'));

// Администратор не наследует ничего, но обладает всеми привилегиями
$acl->allow('administrator');]]>
        </programlisting>

        <para>
            Значение <code>null</code> в вызовах
            <code>allow()</code> в этом примере используется для
            указания того, что правила, предоставляющие доступ,
            применяются ко всем ресурсам.
        </para>

    </sect2>

    <sect2 id="zend.acl.introduction.querying">
        <title>Запросы к ACL</title>

        <para>
            Теперь у нас есть гибкий ACL, который может использоваться для
            определения того, достаточно ли прав имеет запрашивающий, чтобы
            производить действия в веб-приложении. Используя метод
            <code>isAllowed()</code>, производить запросы достаточно
            просто:
        </para>

        <programlisting role="php"><![CDATA[<?php
echo $acl->isAllowed('guest', null, 'view') ?
     "allowed" : "denied"; // allowed

echo $acl->isAllowed('staff', null, 'publish') ?
     "allowed" : "denied"; // denied

echo $acl->isAllowed('staff', null, 'revise') ?
     "allowed" : "denied"; // allowed

echo $acl->isAllowed('editor', null, 'view') ?
     "allowed" : "denied"; // allowed из-за наследования от Гостя

echo $acl->isAllowed('editor', null, 'update') ?
     "allowed" : "denied"; // denied, так как нет разрешающего правила для 'обновления'

echo $acl->isAllowed('administrator', null, 'view') ?
     "allowed" : "denied"; // allowed, т.к. администратор обладает всеми привилегиями

echo $acl->isAllowed('administrator') ?
     "allowed" : "denied"; // allowed, т.к. администратор обладает всеми привилегиями

echo $acl->isAllowed('administrator', null, 'update') ?
     "allowed" : "denied"; // allowed, т.к. администратор обладает всеми привилегиями]]>
        </programlisting>

    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
