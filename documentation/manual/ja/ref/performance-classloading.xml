<?xml version="1.0" encoding="UTF-8"?>
<!-- Reviewed: no -->
<!-- EN-Revision: 15099 -->
<sect1 id="performance.classloading">
    <title>クラスの読み込み</title>

    <para>
        Zend Frameworkアプリケーションのプロファイルをとってみた人は誰でも、
        Zend Frameworkではクラスの読み込みが比較的高くつくことにすぐ気がつくでしょう。
        Between the sheer number of class files that need to be
        loaded for many components, to the use of plugins that do not have a 1:1
        relationship between their class name and the file system, the various
        calls to <code>include_once</code> and <code>require_once</code> can be
        problematic. 
        この章ではこれらの問題に対して確立したいくつかの解決方法を提示するつもりです。
    </para>

    <sect2 id="performance.classloading.includepath">
        <title>どのようにしたらinclude_pathを最適化できますか？</title>

        <para>
            クラスの読み込み速度を向上させるためにあなたができるささやかな最適化の
            ひとつはinclude_pathに注意をはらうことです。
            特に４つのことをすべきでしょう:
            絶対パスを使うこと（または相対パスを絶対パスに変えること）、
            定義したincludeパスの数を減らすこと、
            include_pathにZend Frameworkをできる限り先に設定すること、
            そして現行ディレクトリパスをinclude_pathの最後にだけincludeすることです。
        </para>

        <sect3 id="performance.classloading.includepath.abspath">
            <title>絶対パスを使う</title>

            <para>
                これは些細な最適化に見えますが、実は、やらなければPHPのrealpathキャッシュの
                恩恵がほとんど受けられません。
                結果として、あなたが期待するようにはopcodeキャッシュもほとんど動作しません。
            </para>

            <para>
                このことを確かめる易しい方法が２つあります。
                ひとつはパスをphp.iniやhttpd.confもしくは .htaccessで
                ハードコーディングすることです。
                もうひとつはPHPの<code>realpath()</code>関数を使ってinclude_pathを
                設定することです:
            </para>

            <programlisting role="php"><![CDATA[
$paths = array(
    realpath(dirname(__FILE__) . '/../library'),
    '.',
);
set_include_path(implode(PATH_SEPARATOR, $paths);
]]></programlisting>

            <para>
                You <emphasis>can</emphasis> use 相対パス -- so long as
                they are relative to an absolute path:
            </para>

            <programlisting role="php"><![CDATA[
define('APPLICATION_PATH', realpath(dirname(__FILE__)));
$paths = array(
    APPLICATION_PATH . '/../library'),
    '.',
);
set_include_path(implode(PATH_SEPARATOR, $paths);
]]></programlisting>

            <para>
                However, even so, it's typically a trivial task to simply pass
                the path to <code>realpath()</code>.
            </para>
        </sect3>

        <sect3 id="performance.classloading.includepath.reduce">
            <title>定義したincludeパスの数を減らす</title>

            <para>
                includeパスはinclude_pathに記載された順番にスキャンされます。
                ファイルが後からではなく最初のほうのスキャンで見つかれば、
                結果を早く得られることをこのことは明らかに意味します。
                Thus, a rather obvious enhancement is to simply reduce the
                number of paths in your include_path to only what you need. Look
                through each include_path you've defined, and determine if you
                actually have any functionality in that path that is used in
                your application; if not, remove it.
            </para>

            <para>
                Another optimization is to combine paths. For instance, Zend
                Framework follows PEAR naming conventions; thus, if you are
                using PEAR libraries (or libraries from another framework or
                component library that follows PEAR CS), try to put all of these
                libraries on the same include_path. This can often be achieved
                by something as simple as symlinking one or more libraries into
                a common directory.
            </para>
        </sect3>

        <sect3 id="performance.classloading.includepath.early">
            <title>Zend Frameworkのinclude_pathを出来るだけ先に定義する</title>

            <para>
                前述の提案に引き続き、Zend Frameworkのinclude_pathをinclude_pathの
                中でできる限り先に定義することも別の明らかな最適化です。
                多くの場合、そのリストの中の一番最初のパスになるでしょう。
                このことによりZend Frameworkからincludeされるファイルが最初の
                スキャンで見つかることを保証します。
            </para>
        </sect3>

        <sect3 id="performance.classloading.includepath.currentdir">
            <title>現行ディレクトリは最後に定義するか、または定義しない</title>

            <para>
                Most include_path examples show using the current directory, or
                '.'. This is convenient for ensuring that scripts in the same
                directory as the file requiring them can be loaded. However,
                these same examples typically show this path item as the first
                item in the include_path -- which means that the current
                directory tree is always scanned first. In most cases, with Zend
                Framework applications, this is not desired, and the path may be
                safely pushed to the last item in the list.
            </para>

        <example id="performance.classloading.includepath.example">
            <title>例: 最適化されたinclude_path</title>

            <para>
                Let's put all of these suggestions together. Our assumption will
                be that you are using one or more PEAR libraries in conjunction
                with Zend Framework -- perhaps the PHPUnit and Archive_Tar
                libraries -- and that you occasionally need to include
                files relative to the current file.
            </para>

            <para>
                First, we'll create a library directory in our project. Inside
                that directory, we'll symlink our Zend Framework's library/Zend
                directory, as well as the necessary directories from our PEAR
                installation:
            </para>

            <programlisting role="php"><![CDATA[
library
    Archive/
    PEAR/
    PHPUnit/
    Zend/
]]></programlisting>

            <para>
                This allows us to add our own library code if necessary, while
                keeping shared libraries intact.
            </para>

            <para>
                Next, we'll opt to create our include_path programmatically
                within our public/index.php file. This allows us to move our
                code around on the file system, without needing to edit the
                include_path every time.
            </para>

            <para>
                We'll borrow ideas from each of the suggestions above: we'll use
                absolute paths, as determined using <code>realpath()</code>;
                we'll include the Zend Framework includeパス early; we've
                already consolidated include_paths; and we'll put the current
                directory as the last path. In fact, we're doing really well
                here -- we're going to end up with only two paths.
            </para>

            <programlisting role="php"><![CDATA[
$paths = array(
    realpath(dirname(__FILE__) . '/../library'),
    '.'
);
set_include_path(implode(PATH_SEPARATOR, $paths));
]]></programlisting>
        </example>
        </sect3>
    </sect2>

    <sect2 id="performance.classloading.striprequires">
        <title>どのようにしたら不要なrequire_once文を除去できますか？</title>

        <para>
            Lazy loading is an optimization technique designed to push the
            expensive operation of loading a class file until the last possible
            moment -- i.e., when instantiating an object of that class, calling
            a static class method, or referencing a class constant or static
            property. PHP supports this via autoloading, which allows you to
            define one or more callbacks to execute in order to map a class name
            to a file.
        </para>

        <para>
            However, most benefits you may reap from autoloading are negated if
            your library code is still performing require_once calls -- which is
            precisely the case with Zend Framework. So, the question is: how can
            you eliminate those require_once calls in order to maximize
            autoloader performance?
        </para>

        <sect3 id="performance.classloading.striprequires.sed">
            <title>findおよびsedコマンドを使ってrequire_onceの呼び出しを取り去る</title>

            <para>
                An easy way to strip require_once calls is to use the UNIX
                utilities 'find' and 'sed' in conjunction to comment out each
                call. Try executing the following statements (where '%'
                indicates the shell prompt):
            </para>

            <programlisting role="shell"><![CDATA[
% cd path/to/ZendFramework/library
% find . -name '*.php' -print0 | xargs -0 \
  sed --regexp-extended --in-place 's/(require_once)/\/\/ \1/g'
]]></programlisting>

            <para>
                This one-liner (broken into two lines for readability) iterates
                through each PHP file and tells it to replace each instance of
                'require_once' with '// require_once', effectively commenting
                out each such statement.
            </para>

            <para>
                This command could be added to an automated build or release
                process trivially, helping boost performance in your production
                application. It should be noted, however, that if you use this
                technique, you <emphasis>must</emphasis> utilize autoloading;
                you can do that from your "public/index.php" file with the
                following code:
            </para>

            <programlisting role="php"><![CDATA[
require_once 'Zend/Loader.php'; // one require_once is still necessary
Zend_Loader::registerAutoload();
]]></programlisting>
        </sect3>
    </sect2>

    <sect2 id="performance.classloading.pluginloader">
        <title>どのようにしたらプラグインの読み込みを速く出来ますか？</title>

        <para>
            Many components have plugins, which allow you to create your own
            classes to utilize with the component, as well as to override
            existing, standard plugins shipped with Zend Framework. This
            provides important flexibility to the framework, but at a price:
            plugin loading is a fairly expensive task.
        </para>

        <para>
            The plugin loader allows you to register class prefix / path pairs,
            allowing you to specify class files in non-standard paths. Each
            prefix can have multiple paths associated with it.
            Internally, the plugin loader loops through each prefix, and then
            through each path attached to it, testing to see if the file exists
            and is readable on that path. It then loads it, and tests to see
            that the class it is looking for is available. As you might imagine,
            this can lead to many stat calls on the file system.
        </para>

        <para>
            Multiply this by the number of components that use the PluginLoader,
            and you get an idea of the scope of this issue. At the time of this
            writing, the following components made use of the PluginLoader:
        </para>

        <itemizedlist>
            <listitem><para>
                <classname>Zend_Controller_Action_HelperBroker</classname>: ヘルパ
            </para></listitem>

            <listitem><para>
                <classname>Zend_Dojo</classname>: ビューヘルパ、フォーム要素およびデコレータ
            </para></listitem>

            <listitem><para>
                <classname>Zend_File_Transfer</classname>: アダプタ
            </para></listitem>

            <listitem><para>
                <classname>Zend_Filter_Inflector</classname>: フィルタ
                (ViewRendererアクションヘルパおよびZend_Layoutに使用されます)
            </para></listitem>

            <listitem><para>
                <classname>Zend_Filter_Input</classname>: フィルタおよびバリデータ
            </para></listitem>

            <listitem><para>
                <classname>Zend_Form</classname>: 要素、バリデータ、フィルタ、
                デコレータ、キャプチャ、ファイル転送アダプタ
            </para></listitem>

            <listitem><para>
                <classname>Zend_Paginator</classname>: アダプタ
            </para></listitem>

            <listitem><para>
                <classname>Zend_View</classname>: ヘルパ、フィルタ
            </para></listitem>
        </itemizedlist>

        <para>
            どのようにしたらそのような生成された呼び出しの数を減らせますか？
        </para>

        <sect3
            id="performance.classloading.pluginloader.includefilecache">
            <title>ファイルキャッシュを含むPluginLoaderを使う</title>

            <para>
                Zend Frameworkの1.7.0でPluginLoaderにincludeファイルキャッシュが
                追加されました。
                This functionality writes "include_once" calls to
                a file, which you can then include in your bootstrap. While this
                introduces extra include_once calls to your code, またそのことは
                PluginLoaderができるだけ早く returns <!-- TODO --> することを保証します。
            </para>

            <para>
                PluginLoaderのドキュメントに<link
                    linkend="zend.loader.pluginloader.performance.example">
                    その使い方の完全な例があります</link>。
            </para>
        </sect3>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
