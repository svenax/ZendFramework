<sect1 id="zend.db.select">

    <title>Zend_Db_Select</title>

    <sect2 id="zend.db.select.introduction">

        <title>Descripción del Objeto Select</title>

        <para>
            El objeto Zend_Db_Select object representa una declaración de consulta
            <code>SELECT</code> de SQL. La clase tiene métodos para agregar partes
            individuales a la consulta. Se pueden especificar algunas partes de la consulta
            usando los métodos en PHP y sus estructuras de datos, y la clase forma la sintaxis
            SLQ correcta. Después de construir la consulta, puede ejecutarla como si
            se hubiera escrito como un string.
        </para>

        <para>
            Las posibilidades de Zend_Db_Select incluyen:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    Métodos Orientados a objetos para especificar consultas SQL
                    pieza-a-pieza;
                </para>
            </listitem>

            <listitem>
                <para>
                    Abstracción de partes de las consultas SQL, independiente de la
                    Base de datos;
                </para>
            </listitem>

            <listitem>
                <para>
                    Entrecomillado automático de identificadores de metadatos en
                    la mayoría de los casos, soportanto identificadores que contienen palabras
                    reservadas de SQL y caracteres especiales;
                </para>
            </listitem>

            <listitem>
                <para>
                    Entrecomillado de identificadores y valores, para ayudar a reducir el
                    riesgo de ataque por inyección SQL.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            El uso de Zend_Db_Select no es obligatorio. Para consultas SELECT muy simples,
            es usualmente más simple especificar la consulta completa como un string
            y ejecutarla usando un método del Adapter como <code>query()</code> o
            <code>fetchAll()</code>. Usar Zend_Db_Select es útil si se necesita ensamblar
            una consulta SELECT proceduralmente, o basada en condiciones lógicas en
            la aplicación.
        </para>

    </sect2>

    <sect2 id="zend.db.select.creating">

        <title>Creando un Objeto Select</title>

        <para>
            Se puede crear una instancia del objeto Zend_Db_Select usando el método
            <code>select()</code> de un objeto Zend_Db_Adapter_Abstract.
        </para>

        <example id="zend.db.select.creating.example-db">

            <title>Ejemplo del método select() del adaptador</title>

            <programlisting role="php"><![CDATA[
$db = Zend_Db::factory( ...options... );
$select = $db->select();
]]>
            </programlisting>

        </example>

        <para>
            Otra manera de crear el objeto Zend_Db_Select es con su constructor,
            especificando el adaptador de base de datos como un argumento.
        </para>

        <example id="zend.db.select.creating.example-new">

            <title>Ejemplo de creación de un nuevo objeto Select</title>

            <programlisting role="php"><![CDATA[
$db = Zend_Db::factory( ...options... );
$select = new Zend_Db_Select($db);
]]>
            </programlisting>

        </example>

    </sect2>

    <sect2 id="zend.db.select.building">

        <title>Construyendo consultas Select</title>

        <para>Cuando se construye una consulta, puede agregar cláusulas a ésta, una por una.
            Hay un método separado para agregar cada una al objeto Zend_Db_Select.</para>

        <example id="zend.db.select.building.example">

            <title>Ejemplo de uso de métodos que agregan cláusulas</title>

            <programlisting role="php"><![CDATA[
// Crear el objeto Zend_Db_Select
$select = $db->select();

// Agregar una cláusula FROM
$select->from( ...specify table and columns... )

// Agregar una cláusula WHERE
$select->where( ...specify search criteria... )

// Agregar una cláusula ORDER BY
$select->order( ...specify sorting criteria... );
]]>
            </programlisting>

        </example>

        <para>También puede utilizar la mayoría de los métodos del objeto Zend_Db_Select con una
        interfaz fluida. Una interfaz fluida significa que cada método devuelve una referencia
            al objeto que se ha llamado, así se puede llamar inmediatamente a otro método.</para>

        <example id="zend.db.select.building.example-fluent">

            <title>Ejemplo de uso de la interfaz fluida.</title>

            <programlisting role="php"><![CDATA[
$select = $db->select()
    ->from( ...specify table and columns... )
    ->where( ...specify search criteria... )
    ->order( ...specify sorting criteria... );
]]>
            </programlisting>

        </example>

        <para>Los ejemplos en esta sección muestran el uso de la interfaz fluída, pero también
            se puede usar la interfaz no-fluída en todos los casos. A menudo es necesario
            utilizar la interfaz no-fluída, por ejemplo, si su aplicación necesita realizar
            cierta lógica antes de añadir una cláusula a la consulta.</para>

        <sect3 id="zend.db.select.building.from">

            <title>Agregando una cláusula FROM</title>

            <para>
                Especifique la tabla para esta consulta usando el método <code>from()</code>.
                Se puede especificar el nombre de la tabla como un string. Zend_Db_Select
                aplica el identificador entrecomillando el nombre de la tabla, así puede
                utilizar caracteres especiales.
            </para>

            <example id="zend.db.select.building.from.example">

                <title>Ejemplo del método from()</title>

                <programlisting role="php"><![CDATA[
// Construye la consulta:
//   SELECT *
//   FROM "products"

$select = $db->select()
             ->from( 'products' );
]]>
                </programlisting>

            </example>

            <para>
                Puede especificar un nombre de correlación (también llamado a veces
                "alias de tabla") para una tabla. En lugar de un string, se usa un
                array asociativo que mapee el nombre de correlación con el nombre de la tabla.
                En otras cláusulas de consulta SQL, utilice nombre de correlación.
                Si su consulta se une con más de una tabla, Zend_Db_Select genera una
                correlación unica de nombres basados en el nombre de la tabla, para una tabla
                a la cual no se le espicifique un nombre de correlación.
            </para>

            <example id="zend.db.select.building.from.example-cname">

                <title>Ejemplo especificando una tabla con nombre de correlación</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT p.*
//   FROM "products" AS p

$select = $db->select()
             ->from( array('p' => 'products') );
]]>
                </programlisting>

            </example>

            <para>
                Algunos RDBMS apoyan el uso de un especificador de esquema para una tabla.
                Puede especificar el nombre de la tabla como
                "<code>nombreDeEsquema.nombre DeTabla</code>", donde Zend_Db_Select entrecomillará
                cada parte individualmente, o tambien puedes especificar el nombre de esquema
                por separado. Un nombre de esquema especificado en el nombre de la tabla toma
                precedencia en sobre un esquema dado por separado en el caso de que ambos
                sean dados.
            </para>

            <example id="zend.db.select.building.from.example-schema">

                <title>Ejemplo especificando un nombre de esquema</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT *
//   FROM "myschema"."products"

$select = $db->select()
             ->from( 'myschema.products' );

// o

$select = $db->select()
             ->from('products', '*', 'myschema');
]]>
                </programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.columns">

            <title>Agregando Columnas</title>

            <para>
                En el segundo argumento del método <code>from()</code>, puede especificar
                las columnas que seleccionar desde la tabla respectiva.
                Si no especifica columnas, por defecto será "<code>*</code>",
                el comodín SQL para "todas las columnas".
            </para>

            <para>
                Puede listar las columnas en un simple array de strings, o en un
                array asociativo mapeando los alias de columnas a su nombre de tabla.
                Si solo se especifica una columna en la consulta y no necesita especificar un
                alias de columna, puede listarla solo con un string en lugar de un array.
            </para>

            <para>
                Si se entrega un array vacío como el argumento de las tablas, no se incluirán
                columnas en el resultado. Vea un
                <link linkend="zend.db.select.building.join.example-no-columns">código de ejemplo</link>
                en la sección del método <code>join()</code>.
            </para>

            <para>
                Puedes especificar el nombre de columna como
                "<code>nombreCorrelacionado.nombreDeColumna</code>".
                Zend_Db_Select entrecomillará cada parte individualmente. Si no especifica
                un nombre de correlación para una columna, se usará el nombre de correlación
                para la tabla nombrada en el método actual <code>from()</code>.
            </para>

            <example id="zend.db.select.building.columns.example">

                <title>Ejemplos especificando columnas</title>

                <programlisting role="php"><![CDATA[
// Construir esta consulta:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'));

// Construir la misma consulta, especificando nombres de correlación
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('p.product_id', 'p.product_name'));

// Construir esta consulta con una alias para una columna:
//   SELECT p."product_id" AS prodno, p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('prodno' => 'product_id', 'product_name'));
]]>
                </programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.columns-expr">

            <title>Agregando una Expresión en las Columns</title>

            <para>
                Las columnas en consultas SQL a veces son expresiones, no simples columnas
                de una tabla. Las expresiones no deberían tener nombres de correlación o entrecomillado aplicado.
                Si sus columnas contienen paréntesis, Zend_Db_Select las reconoce como una expresión.
            </para>

            <para>
                Tambien puede crear un objeto de tipo Zend_Db_Expr explícitamente, para prevenir
                que el string sea tratado como columna. Zend_Db_Expr es una clase mínima, que contiene
                un simple string. Zend_Db_Select reconoce el objeto de tipo Zend_Db_Expr y
                lo convierte de vuelta en el string, pero no le aplica ninguna alteración,
                tal como el entrecomillado o la correlación de nombres.
            </para>

            <note>

                <para>
                    El Uso de Zend_Db_Expr para nombres de columnas no es necesario si
                    la expresión de la columna contiene paréntesis; Zend_Db_Select reconoce
                    y trata el string como expresión, saltándose el entrecomillado y la
                    correlación de nombres.
                </para>

            </note>

            <example id="zend.db.select.building.columns-expr.example">

                <title>Ejemplos especificando columnas que contienen expresiones</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", LOWER(product_name)
//   FROM "products" AS p
// Una expresion con parentesis implicitamente se transforma en
// un Zend_Db_Expr.

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'LOWER(product_name)'));

// Construya esta consulta:
//   SELECT p."product_id", (p.cost * 1.08) AS cost_plus_tax
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id',
                          'cost_plus_tax' => '(p.cost * 1.08)')
                   );

// Construya esta consulta usando Zend_Db_Expr explícitamente:
//   SELECT p."product_id", p.cost * 1.08 AS cost_plus_tax
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id',
                          'cost_plus_tax' =>
                              new Zend_Db_Expr('p.cost * 1.08'))
                    );
]]>
                </programlisting>

            </example>

            <para>
                En los casos anteriores, Zend_Db_Select no altera el string para aplicar
                correlación de nombres o entrecomillado de identificadores. Si estos
                cambios son necesarios para resolver ambigüedades, deberías realizar
                cambios manualmente en el string.
            </para>

            <para>
                Si el nombre de su columna es alguna palabra reservada de SQL o
                contiene caracteres especiales, debería usar el método
                <code>quoteIdentifier()</code> del Adapdator e interpolar el resultado en un
                string. El método <code>quoteIdentifier()</code> usa entrecomillado SQL para
                delimitar el identificador,
                the identifier, dejando en claro que es un identificador de tabla o columna y no
                otra parte de la sintaxis SQL.
            </para>

            <para>
                Su código es más independiente de la base de datos si se usa el método
                <code>quoteIdentifier()</code> en vez de las excribir literalmente las comillas
                en la cadena, debido a que algunos RDBMS no usan simbolos estándar para entrecomillar
                identificadores.
                El método <code>quoteIdentifier()</code> está diseñado para usar los símbolos
                apropiados para entrecomillar basado en el tipo del adaptador.
                El método <code>quoteIdentifier()</code> también escapa
                cual caracter de comilla que aparezca en el nombre del identificador mismo.
            </para>

            <example id="zend.db.select.building.columns-quoteid.example">

                <title>Ejemplo de entrecomillado de columnas en una expresión</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta, entrecomillando el nombre
// especial de la columna llamada "from" en la expresión:
//   SELECT p."from" + 10 AS origin
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('origin' =>
                              '(p.' . $db->quoteIdentifier('from') . ' + 10)')
                   );
]]>
                </programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.columns-atomic">

            <title>Agregar columnas a una tabla FROM o JOIN existente</title>

            <para>
                Puede haber casos en los que desea agregar columnas a una tabla FROM o JOIN
                después de que estos métodos han sido llamados. El método <code>columns()</code>
                permite agregar columnas en cualquier punto antes de ejecutar la consulta.
                Puedes pasar las columnas bien como un string, un <code>Zend_Db_Expr</code> o
                un array de estos elementos. El segundo argumento para este método puede ser omitido,
                implicando que las columnas serán agregadas a una tabla FROM, en otro caso
                debería usarse un nombre de correlación existente.
            </para>

            <example id="zend.db.select.building.columns-atomic.example">

                <title>Ejemplos agregando columnas con el método<code>columns()</code></title>

                <programlisting role="php"><![CDATA[
// Construir la consulta:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'), 'product_id')
             ->columns('product_name');

// Construir la misma consulta, especificando correlación de nombres:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->from(array('p' => 'products'), 'p.product_id')
             ->columns('product_name', 'p');
             // Alternativamente puede usar columns('p.product_name')]]>
                </programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.join">

            <title>Agregar Otra Tabla a la Consulta Query con JOIN</title>

            <para>
                Muchas consultas útiles involucran el uso de un <code>JOIN</code> para
                combinar filas de multiples tablas. Puedes agregar tablas a una consulta Zend_Db_Select
                usando el método <code>join()</code>. Usar este método, es similar
                al método <code>from()</code>, excepto que puedes especificar una condición de unión
                en la mayoría de los casos.
            </para>

            <example id="zend.db.select.building.join.example">

                <title>Ejemplo del método join()</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", p."product_name", l.*
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id');
]]>
                </programlisting>

            </example>

            <para>
                El segundo argumento <code>join()</code> es un string que es usado como condición de unión.
                Esta es una expresión que declara un criterio por el cual las filas en una tabla concuerdan con
                las filas de la otra tabla. Puedes especificar correlación de nombres en esta expresión.
            </para>

            <note>

                <para>
                    No se aplica entrecomillado en la expresión especificada para la condición de unión;
                    si tienes problemas con nombres que necesitan ser entrecomillados, deberás usar
                    <code>quoteIdentifier()</code> para formar el string de condición de unión.
                </para>

            </note>

            <para>
                El tercer argumento <code>join()</code> es un array de nombres de columnas, como
                al usar el método <code>from()</code>. Este es por defecto "<code>*</code>", soporta
                correlación de nombres, expresiones, y Zend_Db_Expr de la misma manera que el array de
                nombres de columnas en el método <code>from()</code>.
            </para>

            <para>
                Para no seleccionar columnas de una tabla, use un array vacío para la lista de columnas.
                El uso de esto trabaja con el método <code>from()</code> también, pero en general
                deseará algunas columnas de la tabla primaria en sus consultas, a la vez que no se desean
                columnas de la tabla unida.
            </para>

            <example id="zend.db.select.building.join.example-no-columns">

                <title>Ejemplo especificando ninguna columna</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array() ); // empty list of columns
]]>
                </programlisting>

                <para>
                    Note el array vacío <code>array()</code> en el ejemplo anterior
                    en lugar de una lista de columnas de la tabla unida.
                </para>

            </example>

            <para>
                SQL tiene muchos tipos de uniones. Vea una lista a continuación para los métodos
                que soporta cada tipo de unión en Zend_Db_Select.
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <command>INNER JOIN</command> con los métodos
                        <code>join(table, join, [columns])</code> o
                        <code>joinInner(table, join, [columns])</code>.
                    </para>

                    <para>
                        Éste es el tipo de unión más comun. Las filas de cada tabla son comparadas
                        usando la condición de unión especificada. El resultado incluye solo las filas
                        que satisfacen la condición. El resultado puede ser vacío si no hay filas que
                        satisfagan la condición.
                    </para>

                    <para>
                        Todos los RDBMS soportan este tipo de unión.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>LEFT JOIN</command> con el método
                        <code>joinLeft(table, condition, [columns])</code>.
                    </para>

                    <para>
                        Todas las filas de tabla a la izquierda del operando son incluidas,
                        pareando las filas de la tabla a la derecha del operando,
                        y las columnas de la tabla a la derecha del operando son rellenadas con
                        NULLs si no existen filas que coincidan con la tabla a la izquierda.
                    </para>

                    <para>
                        Todos los RDBMS soportan este tipo de unión.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>RIGHT JOIN</command> con el método
                        <code>joinRight(table, condition, [columns])</code>.
                    </para>

                    <para>
                        Unión exterior por la derecha es el complementario de la unión exterior por la
                        izquierda. Todas las filas de la tabla a la derecha del operando son incluidas,
                        pareando las filas de la tabla a la izquierda del operando incluidas, y las
                        columnas de la tabla a la izquierda del operando son rellenadas con NULLs si
                        no existen filas que coincidan con la tabla de la derecha.
                    </para>

                    <para>
                        Algunos RDBMS no soportan este tipo de join, pero en general, cualquier unión
                        por la derecha puede representarse por una unión por la izquierda invirtiendo
                        el orden de las tablas.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>FULL JOIN</command> con el método
                        <code>joinFull(table, condition, [columns])</code>.
                    </para>

                    <para>
                        Una unión externa total es como una combinación de una unión exterior por
                        la izquierda y una unión exterior por la derecha.
                        Todas las filas de ambas tablas son incluidas, vinculadas entre sí
                        en la  misma fila si satisfacen la condición de unión, y en otro
                        caso, se vinculan con valores nulos en lugar de columnas de la otra tabla.
                    </para>

                    <para>
                        Algunos RDBMS no soportan este tipo de unión.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>CROSS JOIN</command> con el método
                        <code>joinCross(table, [columns])</code>.
                    </para>

                    <para>
                        Una unión cruzada es un Producto Cartesiano. Cada fila en la primera tabla
                        es pareada con cada una en la segunda tabla.
                        Por lo tanto, el número de filas en el resultado es igual al producto del
                        número de filas en cada tabla.
                        Puede filtrar el conjunto de resultados con el uso de condiciones en un
                        cláusula WHERE; de esta forma una unión cruzada es similar a la antigua
                        sintaxis de unión en SQL-89.
                    </para>

                    <para>
                        El método <code>joinCross()</code> no tiene parámetros para especificar una
                        condición de unión. Algunos RDBMS no soportan este tipo de unión.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <command>NATURAL JOIN</command> con el método
                        <code>joinNatural(table, [columns])</code>.
                    </para>

                    <para>
                        Una unión natural compara cualquier columa(s) que aparezca con el nombre
                        en ambas tablas. La comparación es el equivalente de todas las columna(s);
                        comparando las columnas usando desigualdad no es una unión natural.
                        Solo la unión interna natural es soportada por este API, aun cuando SQL
                        permita una unión externa natural.
                    </para>

                    <para>
                        El método <code>joinNatural()</code> no tiene parámetros para especificar una condición.
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                Además de los métodos de unión, puede simplificar las consultas
                usando métodos JoinUsing. En vez de proveer una condición completa a la unión,
                simplemente pase el nombre de columna en la que se hará la unión y
                el objeto Zend_Db_Select completa la condición.
            </para>

            <example id="zend.db.select.building.joinusing.example">

                <title>Ejemplo de método joinUsing()</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT *
//   FROM "table1"
//   JOIN "table2"
//   ON "table1".column1 = "table2".column1
//   WHERE column2 = 'foo'

$select = $db->select()
             ->from('table1')
             ->joinUsing('table2', 'column1')
             ->where('column2 = ?', 'foo');]]>
                </programlisting>

            </example>

            <para>
                Cada uno de los métodos aplicables para uniones en el componente
                Zend_Db_Select tiene su correspondiente método 'using' (usando)
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <code>joinUsing(table, join, [columns])</code> y
                        <code>joinInnerUsing(table, join, [columns])</code>
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <code>joinLeftUsing(table, join, [columns])</code>
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <code>joinRightUsing(table, join, [columns])</code>
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <code>joinFullUsing(table, join, [columns])</code>
                    </para>
                </listitem>
            </itemizedlist>

        </sect3>

        <sect3 id="zend.db.select.building.where">

            <title>Agregar una cláusula WHERE</title>

            <para>
                Puede especificar un criterio para restringir las filas de resultado
                usando el método <code>where()</code>. El primer argumento de este método
                es una expresión SQL, y esta expresión es usada como una expresión SQL
                <code>WHERE</code> en la consulta.
            </para>

            <example id="zend.db.select.building.where.example">

                <title>Ejemplo del método where()</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE price > 100.00

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price > 100.00');]]>
                </programlisting>

            </example>

            <note>

                <para>
                    No se aplica entrecomillado en una expresión dada en el método <code>where()</code> u
                    <code>orWhere()</code>. Si tiene nombres de columnas que necesitan ser entrecomillados,
                    debe usar el método <code>quoteIdentifier()</code> para formar el string de la condición.
                </para>

            </note>

            <para>
                El segundo argumento del método <code>where()</code> es opcional.
                Es un valor para sustituir en la expresión. Zend_Db_Select entrecomilla el valor
                y lo sustituye por un signo de interrogación ("<code>?</code>") en la expresión.
            </para>

            <para>
                Este método acepta solo un parámetro. Si tiene una expresión
                en la cual necesita sustituir múltiples variables, deberá formar
                el string manualmente, interpolando variables y realizando entrecomillado
                manualmente.
            </para>

            <example id="zend.db.select.building.where.example-param">

                <title>Ejemplo de parámetro en el método where()</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price > 100.00)

$minimumPrice = 100;

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price > ?', $minimumPrice);
]]>
                </programlisting>

            </example>

            <para>
                Puede invocar el método <code>where()</code> múltiples veces en el mismo objeto
                Zend_Db_Select. La consulta resultante combina los términos multiples
                usando <code>AND</code> entre ellos.
            </para>

            <example id="zend.db.select.building.where.example-and">

                <title>Ejemplo de métodos where() múltiples</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price > 100.00)
//     AND (price < 500.00)

$minimumPrice = 100;
$maximumPrice = 500;

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price > ?', $minimumPrice)
             ->where('price < ?', $maximumPrice);
]]>
                </programlisting>

            </example>

            <para>
                Si necesita combinar terminos usando<code>OR</code>, use el método
                <code>orWhere()</code>. Este método se usa del mismo modo que el método
                <code>where()</code>, excepto que el término especificado es precedido por
                <code>OR</code>, en lugar de <code>AND</code>.
            </para>

            <example id="zend.db.select.building.where.example-or">

                <title>Ejemplo del método orWhere()</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price < 100.00)
//     OR (price > 500.00)

$minimumPrice = 100;
$maximumPrice = 500;

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where('price < ?', $minimumPrice)
             ->orWhere('price > ?', $maximumPrice);
]]>
                </programlisting>

            </example>

            <para>
                Zend_Db_Select automáticamente pone paréntesis alrededor de cada expresión
                que especifique usando el método <code>where()</code> u <code>orWhere()</code>.
                Esto ayuda a asegurar que la precedencia del operador Booleano no cause resultados
                inesperados.
            </para>

            <example id="zend.db.select.building.where.example-parens">

                <title>Ejemplos de Expresiones Booleanas con paréntesis</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT product_id, product_name, price
//   FROM "products"
//   WHERE (price < 100.00 OR price > 500.00)
//     AND (product_name = 'Apple')

$minimumPrice = 100;
$maximumPrice = 500;
$prod = 'Apple';

$select = $db->select()
             ->from('products',
                    array('product_id', 'product_name', 'price'))
             ->where("price < $minimumPrice OR price > $maximumPrice")
             ->where('product_name = ?', $prod);
]]>
                </programlisting>

            </example>

            <para>
                En el ejemplo anterior, los resultados deberían ser diferentes sin paréntesis,
                porque <code>AND</code> tiene precedencia más alta respecto a <code>OR</code>.
                Zend_Db_Select aplica el parentesis con un efecto tal que la expresión en sucesivas
                llamadas al método <code>where()</code> vincula de forma más fuerte el <code>AND</code>
                que combina las expresiones.
            </para>

        </sect3>

        <sect3 id="zend.db.select.building.group">

            <title>Agregando una cláusula GROUP BY</title>

            <para>
                En SQL, la cláusula <code>GROUP BY</code> permite reducir el número
                de filas del resultado de una consulta a una fila por cada valor único
                encontrado en la(s) columna(s) nombrada(s) en la cláusula
                <code>GROUP BY</code>.
            </para>

            <para>
                En Zend_Db_Select, puede especificar la(s) columna(s) que usar para el
                cálculo de grupos de filas usando el método <code>group()</code>.
                El argumento de este método es una columna o un array de columnas
                que se usarán en la cláusula <code>GROUP BY</code>.
            </para>

            <example id="zend.db.select.building.group.example">

                <title>Ejemplo del método group()</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", COUNT(*) AS line_items_per_product
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array('line_items_per_product' => 'COUNT(*)'))
             ->group('p.product_id');
]]>
                </programlisting>

            </example>

            <para>
                Como el array de columnas del método <code>from()</code>, se puede usar
                correlación de nombres en el string de nombre de columna, y la columna será
                entrecomillada como un identificador, salvo que el string contenga paréntesis
                o sea un objeto de tipo Zend_Db_Expr.
            </para>

        </sect3>

        <sect3 id="zend.db.select.building.having">

            <title>Agregando una cláusula HAVING</title>

            <para>
                En SQL, la cláusula <code>HAVING</code> aplica una condición de restricción
                en grupos de filas. Es similar a una cláusula <code>WHERE</code>
                aplicando una condición de restricción a las filas. Pero las 2 cláusulas
                son diferentes porque las condiciones <code>WHERE</code>
                son aplicadas antes que definan los grupos, mientras que las condiciones
                <code>HAVING</code> son aplicadas después que los grupos son definidos.
            </para>

            <para>
                En Zend_Db_Select, puede especificar condiciones para restringir
                grupos usando el método <code>having()</code>. Su uso es similar al
                del método <code>where()</code>. El primer agumento es un string
                conteniendo una expresión SQL. El segundo argumento es un valor
                que es usado para reemplazar un parámetro marcador de posición en la
                expresión SQL. Las expresiones dadas en multiples invocaciones al método
                <code>having()</code> son combinadas usando el operador Booleano
                <code>AND</code>, o el operador <code>OR</code> si usa el método
                <code>orHaving()</code>.
            </para>

            <example id="zend.db.select.building.having.example">

                <title>Ejemplo del método having()</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", COUNT(*) AS line_items_per_product
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id
//   HAVING line_items_per_product > 10

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array('line_items_per_product' => 'COUNT(*)'))
             ->group('p.product_id')
             ->having('line_items_per_product > 10');
]]>
                </programlisting>

            </example>

            <note>

                <para>
                    No se aplica entrecomillado a expresiones dadas al método <code>having()</code> u
                    <code>orHaving()</code>. Si tiene nombres de columnas que deban ser
                    entrecomillados, deberá usar <code>quoteIdentifier()</code> para
                    formar el string de la condición.
                </para>

            </note>

        </sect3>

        <sect3 id="zend.db.select.building.order">

            <title>Agregar una cláusula ORDER BY</title>

            <para>
                En SQL, la cláusula <code>ORDER BY</code> especifica una o más
                columnas o expresiones por el cual el resultado de la consulta
                será ordenado. Si multiples columnas son listadas, las columnas secundarias
                serán usadas para resolver relaciones; el orden de clasificación es determinado
                por columnas secundarias si la columna anterior contiene valores idénticos.
                El orden por defecto es del menor valor al mayor valor. Puede también
                ordenar de mayor a menor valor para una columna dada en la lista espeificando
                la palabra clave <code>DESC</code> después de la columna.
            </para>

            <para>
                En Zend_Db_Select, puede usar el método <code>order()</code>
                para especificar una columna o un array de columnas por el cual ordenar.
                Cada elemento del array es un string nombrando la columna. Opcionalmente con la
                palabra reservada <code>ASC</code> o <code>DESC</code> siguiendola, separada
                por un espacio.
            </para>

            <para>
                Como en el método <code>from()</code> y <code>group()</code>, los nombres de columnas
                son entrecomillados como identificadores, a menos que contengan paréntesis
                o sean un obheto de tipo Zend_Db_Expr.
            </para>

            <example id="zend.db.select.building.order.example">

                <title>Ejemplo del método order()</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", COUNT(*) AS line_items_per_product
//   FROM "products" AS p JOIN "line_items" AS l
//     ON p.product_id = l.product_id
//   GROUP BY p.product_id
//   ORDER BY "line_items_per_product" DESC, "product_id"

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id'))
             ->join(array('l' => 'line_items'),
                    'p.product_id = l.product_id',
                    array('line_items_per_product' => 'COUNT(*)'))
             ->group('p.product_id')
             ->order(array('line_items_per_product DESC',
                           'product_id'));
]]>
                </programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.limit">

            <title>Agregando una cláusula LIMIT</title>

            <para>
                Algunos RDBMS extienden una consulta SQL con una cláusula conocida como <code>LIMIT</code>.
                Esta cláusuala reduce el número de filas en el resultado a no más de un número
                especificado. También puede especificar saltar el número de filas antes
                de empezar la salida. Esta característica hace más fácil tomar un subconjunto de
                resultados, por ejemplo cuando mostramos los resultados de una consulta en
                páginas progresivas de salida.
            </para>

            <para>
                En Zend_Db_Select, puede usar el método <code>limit()</code> para especificar
                la cantidad de filas y el número de filas que saltar. El primer argumento es
                el método es el número de filas deseado. El segundo argument es el número de filas que saltar.
            </para>

            <example id="zend.db.select.building.limit.example">

                <title>Ejemplo del método limit()</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p
//   LIMIT 10, 20

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->limit(10, 20);
]]>
                </programlisting>

            </example>

            <note>

                <para>
                    La sintaxis de <code>LIMIT</code> no está soportada por todos los RDBMS brands.
                    Algunos RDBMS requieren diferente sintaxis para soportar una funcionalidad similar
                    Cada clase Zend_Db_Adapter_Abstract incluye un método
                    para producir el SQL apropiado para cada RDBMS.
                </para>

            </note>

            <para>
                Use el método <code>limitPage()</code> como un modo alternativo de
                especificar la cantidad de filas y el offset.
                Este método permite limitar el conjunto resultado a una serie de subconjuntos
                de tamaño fijo de filas del total del resultado de la consulta.
                En otras palabras, puede especificar el tamaño de una "página" de resultados,
                y el número ordinal de la página simple donde se espera que devuelva la consulta.
                El número de página es el primer argumento del método <code>limitPage()</code>,
                y la longitud de la página es el segundo argumento.
                Ambos son argumentos requeridos; no tienen valores por omisión.
            </para>

            <example id="zend.db.select.building.limit.example2">

                <title>Ejemplo del método limitPage()</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT p."product_id", p."product_name"
//   FROM "products" AS p
//   LIMIT 10, 20

$select = $db->select()
             ->from(array('p' => 'products'),
                    array('product_id', 'product_name'))
             ->limitPage(2, 10);
]]>
                </programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.distinct">

            <title>Agregar el modificador DISTINCT a la consulta</title>

            <para>
                El método <code>distinct()</code> permite agregar la palabra
                clave a la consulta <code>DISTINCT</code> a su consulta SQL.
            </para>

            <example id="zend.db.select.building.distinct.example">

                <title>Ejemplo del método distinct()</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT DISTINCT p."product_name"
//   FROM "products" AS p

$select = $db->select()
             ->distinct()
             ->from(array('p' => 'products'), 'product_name');
]]>
                </programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.building.for-update">

            <title>Agregar el modificador FOR UPDATE</title>

            <para>
                El método <code>forUpdate()</code> permite agregar el modificador
                <code>FOR UPDATE</code> a su consulta SQL.
            </para>

            <example id="zend.db.select.building.for-update.example">

                <title>Example of forUpdate() method</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT FOR UPDATE p.*
//   FROM "products" AS p

$select = $db->select()
             ->forUpdate()
             ->from(array('p' => 'products'));
]]>
                </programlisting>

            </example>

        </sect3>

    </sect2>

    <sect2 id="zend.db.select.execute">

        <title>Ejecutando consultas Select</title>

        <para>
            En esta sección se describe cómo ejecutar una consulta representada por
             un objeto Zend_Db_Select.
        </para>

        <sect3 id="zend.db.select.execute.query-adapter">

            <title>Ejecutando Consultas SelectExecuting desde el Adaptador de Base de Datos</title>

            <para>
                Puede ejecutar la consulta representada por el objeto Zend_Db_Select pasándolo
                como primer argumento al método <code>query()</code> de un objeto Zend_Db_Adapter_Abstract.
                Use objetos Zend_Db_Select en lugar de un string de consulta.
            </para>

            <para>
                El método <code>query()</code> devuelve un objeto de tipo
                Zend_Db_Statement o PDOStatement, dependiendo del tipo de adaptador.
            </para>

            <example id="zend.db.select.execute.query-adapter.example">

                <title>Ejemplo usando el método adaptador query() del Adaptador de Base de datos</title>

                <programlisting role="php"><![CDATA[
$select = $db->select()
             ->from('products');

$stmt = $db->query($select);
$result = $stmt->fetchAll();
]]>
                </programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.execute.query-select">

            <title>Ejecutando Consultas Select desde el Objeto</title>

            <para>
                Como alternativa al uso del método <code>query()</code> del objeto adaptador,
                puede usar el método <code>query()</code> del objeto Zend_Db_Select. Ambos
                métodos devuelven un objeto de tipo Zend_Db_Statement o PDOStatement, dependiendo
                del tipo de adaptador.
            </para>

            <example id="zend.db.select.execute.query-select.example">

                <title>Ejempo usando el método query() del objeto Select</title>

                <programlisting role="php"><![CDATA[
$select = $db->select()
             ->from('products');

$stmt = $select->query();
$result = $stmt->fetchAll();
]]>
                </programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.execute.tostring">

            <title>Convertiendo un Objeto Select a un String SQL</title>

            <para>
                Si necesita acceder a una represantación en un string de la
                consulta SQL correspondiente al objeto Zend_Db_Select,
                use el método <code>__toString()</code>.
            </para>

            <example id="zend.db.select.execute.tostring.example">

                <title>Ejemplo del método __toString()</title>

                <programlisting role="php"><![CDATA[
$select = $db->select()
             ->from('products');

$sql = $select->__toString();
echo "$sql\n";

// La salida es el string:
//   SELECT * FROM "products"
]]>
                </programlisting>

            </example>

        </sect3>

    </sect2>

    <sect2 id="zend.db.select.other">

        <title>Otros Métodos</title>

        <para>
            Esta sección describe otros métodos de Zend_Db_Select que no han
            sido cubiertos antes: <code>getPart()</code> y <code>reset()</code>.
        </para>

        <sect3 id="zend.db.select.other.get-part">

            <title>Obtener Partes de un Objeto Select</title>

            <para>
                El método <code>getPart()</code> devuelve una representación de
                una parte de su consulta SQL. Por ejemplo, puede usar este
                método para devolver un array de expresiones para la cláusula
                <code>WHERE</code>, o el array de columnas (o expresiones de
                columnas) que estan en la lista del <code>SELECT</code>, o los
                valores de la cantidad y comienzo para la cláusula
                <code>LIMIT</code>.
            </para>

            <para>
                El valor de retorno no es un string conteniendo un fragmento
                de la sintaxis SQL. El valor de retorno es una representación,
                típicamente un array con una estructura que contiene valores y
                expresiones. Cada parte de la consulta tiene una estructura
                diferente.
            </para>

            <para>
                El único argumento del método <code>getPart()</code> es un
                string que identifica qué parte del la consulta Select va a
                devolver. Por ejemplo, el string <code>'from'</code> identifica
                la parte del objeto Select que almacena la información de las
                tablas de la cláusula <code>FROM</code>, incluyendo uniones de
                tablas.
            </para>

            <para>
                La clase Zend_Db_Select define constantes que puedes usar para
                las partes de la consulta SQL.
                Puede usar estas definiciones de constantes, o los strings
                literales.
            </para>

            <table id="zend.db.select.other.get-part.table">

                <title>Constantes usedas por getPart() y reset()</title>

                <tgroup cols="2">
                    <thead>
                        <row>
                            <entry>Constante</entry>
                            <entry>Valor del String</entry>
                        </row>
                    </thead>

                    <tbody>
                        <row>
                            <entry><code>Zend_Db_Select::DISTINCT</code></entry>
                            <entry><code>'distinct'</code></entry>
                        </row>

                        <row>
                            <entry><code>Zend_Db_Select::FOR_UPDATE</code></entry>
                            <entry><code>'forupdate'</code></entry>
                        </row>

                        <row>
                            <entry><code>Zend_Db_Select::COLUMNS</code></entry>
                            <entry><code>'columns'</code></entry>
                        </row>

                        <row>
                            <entry><code>Zend_Db_Select::FROM</code></entry>
                            <entry><code>'from'</code></entry>
                        </row>

                        <row>
                            <entry><code>Zend_Db_Select::WHERE</code></entry>
                            <entry><code>'where'</code></entry>
                        </row>

                        <row>
                            <entry><code>Zend_Db_Select::GROUP</code></entry>
                            <entry><code>'group'</code></entry>
                        </row>

                        <row>
                            <entry><code>Zend_Db_Select::HAVING</code></entry>
                            <entry><code>'having'</code></entry>
                        </row>

                        <row>
                            <entry><code>Zend_Db_Select::ORDER</code></entry>
                            <entry><code>'order'</code></entry>
                        </row>

                        <row>
                            <entry><code>Zend_Db_Select::LIMIT_COUNT</code></entry>
                            <entry><code>'limitcount'</code></entry>
                        </row>

                        <row>
                            <entry><code>Zend_Db_Select::LIMIT_OFFSET</code></entry>
                            <entry><code>'limitoffset'</code></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <example id="zend.db.select.other.get-part.example">

                <title>Ejemplo del método getPart()</title>

                <programlisting role="php"><![CDATA[
$select = $db->select()
             ->from('products')
             ->order('product_id');

// Puede especificar un string literal para especificar la parte
$orderData = $select->getPart( 'order' );

// Puede usar una constante para especificar la misma parte
$orderData = $select->getPart( Zend_Db_Select::ORDER );

// El valor de retorno puede ser una estructura en un array, no un string.
// Cada parte tiene distinta estructura.
print_r( $orderData );
]]>
                </programlisting>

            </example>

        </sect3>

        <sect3 id="zend.db.select.other.reset">

            <title>Restableciendo Partes de un Objeto</title>

            <para>
                El método <code>reset()</code> permite limpiar una parte
                específica de la consulta SQL, o limpia todas las partes de la
                consulta SQL si omite el argumento.
            </para>

            <para>
                El argumento es opcional. Puede especificar la parte de la
                consulta que será limpiada, usando los mismos strings que usa el
                argumento del método <code>getPart()</code>. La parte de la
                consulta que especifique se reestablecerá a su estado por
                omisión.
            </para>

            <para>
                Si omite el parámetro, <code>reset()</code> cambia todas las
                partes de la consulta a su estado por omisión. Esto hace que
                el objeto Zend_Db_Select sea equivalente a crear un nuevo
                objeto, como si acabase de instanciarlo.
            </para>

            <example id="zend.db.select.other.reset.example">

                <title>Ejemplo del método reset()</title>

                <programlisting role="php"><![CDATA[
// Construya esta consulta:
//   SELECT p.*
//   FROM "products" AS p
//   ORDER BY "product_name"

$select = $db->select()
             ->from(array('p' => 'products')
             ->order('product_name');

// Requisito cambiado, en su lugar un orden diferente de columnas:
//   SELECT p.*
//   FROM "products" AS p
//   ORDER BY "product_id"

// Limpia una parte para poder redefinirla
$select->reset( Zend_Db_Select::ORDER );

// Y especificar una columna diferente
$select->order('product_id');

// Limpia todas las partes de la consulta
$select->reset();
]]>
                </programlisting>

            </example>

        </sect3>

    </sect2>

</sect1>
<!--
vim:se ts=4 sw=4 et:
-->