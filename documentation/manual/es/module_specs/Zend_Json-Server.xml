<?xml version="1.0" encoding="UTF-8"?>
<!-- Reviewed: no -->
<sect1 id="zend.json.server">
    <title>Zend_Json_Server - servidor JSON-RPC</title>

    <para>
        <classname>Zend_Json_Server</classname> es una implementación del 
            servidor <ulink
            url="http://groups.google.com/group/json-rpc/">JSON-RPC</ulink>
        Soporta tanto la versión 1 de la especificación  
        <ulink url="http://json-rpc.org/wiki/specification">JSON-RPC</ulink> 
        así como la especificación de la 
        <ulink url="http://groups.google.com/group/json-rpc/web/json-rpc-1-2-proposal">versión 2</ulink>;
        además, provee una implementación de PHP de la especificación del
        <ulink url="http://groups.google.com/group/json-schema/web/service-mapping-description-proposal">Service
            Mapping Description (SMD)</ulink>
        para prestar un servicio de metadatos a consumidores del servicio.
    </para>

    <para>
        JSON-RPC es un protocolo liviano de Remote Procedure Call que utiliza JSON 
        para envolver sus mensajes. Esta implementación JSON-RPC sigue la API 
        PHP de <ulink
            url="http://us.php.net/manual/en/function.soap-soapserver-construct.php">SoapServer</ulink>.
        Esto significa que, en una situación típica, simplemente:
    </para>

    <itemizedlist>
        <listitem><para>Instancia el objeto servidor</para></listitem>
        <listitem><para>Agrega una o más funciones y/o clases/objetos al objeto 
                servidor para</para></listitem>
        <listitem><para>handle() -- maneja -- el requerimiento</para></listitem>
    </itemizedlist>

    <para>
        <classname>Zend_Json_Server</classname> utiliza <xref linkend="zend.server.reflection" /> 
        para realizar reflexión sobre cualquiera de las clases o funciones 
        agregadas, y utiliza esa información para construir tanto la SMD y 
        hacer cumplir el método de llamado de firmas. 
        Como tal, es imperativo que cualquier de las funciones agregadas y/o 
        los métodos de clase tengan mínimamente una plena documentación de 
        PHP docblocks: 
    </para>

    <itemizedlist>
        <listitem><para>Todos los parámetros y sus tipos de variables esperados</para></listitem>
        <listitem><para>El tipo de variable del valor de retorno</para></listitem>
    </itemizedlist>

    <para>
        <classname>Zend_Json_Server</classname> escucha por solicitudes POST 
        únicamente en este momento; afortunadamente, la mayoría de las 
        implementaciones del cliente JSON-RPC en los medios en el momento de 
        escribir esto, sólo requieren a POST como es. 
        Esto hace que sea fácil de utilizar el mismo punto final del servidor  
        para manejar a ambas peticiones así como para entregar el servicio SMD, 
        como se muestra en el siguiente ejemplo.
    </para>

    <example id="zend.json.server.usage">
        <title>Uso de Zend_Json_Server</title>

        <para>
            Primero, definir una clase que queramos exponer vía servidor JSON-RPC. 
            Vamos a la clase 'Calculator', y definir los métodos para
            'add', 'subtract', 'multiply', y 'divide':
        </para>

        <programlisting role="php"><![CDATA[
/**
 * Calculator - clase de ejemplo para exponer via JSON-RPC
 */
class Calculator
{
    /**
     * Devuelve la suma de dos variables
     *
     * @param  int $x
     * @param  int $y
     * @return int
     */
    public function add($x, $y)
    {
        return $x + $y;
    }

    /**
     * Devuelve la diferencia de dos variables
     *
     * @param  int $x
     * @param  int $y
     * @return int
     */
    public function subtract($x, $y)
    {
        return $x - $y;
    }

    /**
     * Devuelve el producto de dos variables
     *
     * @param  int $x
     * @param  int $y
     * @return int
     */
    public function multiply($x, $y)
    {
        return $x * $y;
    }

    /**
     * Devuelve la división de dos variables
     *
     * @param  int $x
     * @param  int $y
     * @return float
     */
    public function divide($x, $y)
    {
        return $x / $y;
    }
}
]]></programlisting>

        <para>
            Nótese que cada método tiene un docblock con entradas indicando cada 
            parámetro y su tipo, así como una entrada para el valor de retorno.
            Esto es <emphasis>absolutamente crítico</emphasis> cuando se usa 
            <classname>Zend_Json_Server</classname> -- o cualquier otro 
            componente del servidor en Zend Framework, por esa cuestión.
        </para>

        <para>
            Ahora, crearemos un script para manejar las peticiones:
        </para>

        <programlisting role="php"><![CDATA[
$server = new Zend_Json_Server();

// Indicar que funcionalidad está disponible:
$server->setClass('Calculator');

// Manejar el requerimiento:
$server->handle();
]]></programlisting>

        <para>
            Sin embargo, esto no soluciona el problema de devolución de un SMD 
            para que el cliente JSON-RPC pueda autodescubrir los métodos. 
            Esto puede lograrse determinando el método del requerimiento HTTP, 
            y luego especificando algún servidor de metadatos:
        </para>

        <programlisting role="php"><![CDATA[
$server = new Zend_Json_Server();
$server->setClass('Calculator');

if ('GET' == $_SERVER['REQUEST_METHOD']) {
    // Indica el punto final de la URL, y la versión en uso de JSON-RPC:
    $server->setTarget('/json-rpc.php')
           ->setEnvelope(Zend_Json_Server_Smd::ENV_JSONRPC_2);

    // Capturar el SMD
    $smd = $server->getServiceMap();

    // Devolver el SMD al cliente
    header('Content-Type: application/json');
    echo $smd;
    return;
}

$server->handle();
]]></programlisting>

        <para>
            Si utiliza el servidor JSON-RPC con Dojo toolkit, también necesitará 
            establecer un flag de compatibilidad especial para garantizar 
            que los dos interoperen correctamente:
        </para>


        <programlisting role="php"><![CDATA[
$server = new Zend_Json_Server();
$server->setClass('Calculator');

if ('GET' == $_SERVER['REQUEST_METHOD']) {
    $server->setTarget('/json-rpc.php')
           ->setEnvelope(Zend_Json_Server_Smd::ENV_JSONRPC_2);
    $smd = $server->getServiceMap();

    // Establecer la compatibilidad con Dojo:
    $smd->setDojoCompatible(true);

    header('Content-Type: application/json');
    echo $smd;
    return;
}

$server->handle();
]]></programlisting>
    </example>

    <sect2 id="zend.json.server.details">
        <title>Detalles Avanzados</title>

        <para>
            Aunque la mayor funcionalidad de <classname>Zend_Json_Server</classname> se
            puntualiza en <xref linkend="zend.json.server.usage" />, hay
            más funcionalidad avanzada disponible.
        </para>

        <sect3 id="zend.json.server.details.zendjsonserver">
            <title>Zend_Json_Server</title>

            <para>
                <classname>Zend_Json_Server</classname> es la clase núcleo en la 
                propuesta JSON-RPC; que maneja todas las peticiones y como 
                respuesta devuelve un conjunto de datos. 
                Tiene los siguientes métodos:
            </para>

            <itemizedlist>
                <listitem><para><code>addFunction($function)</code>: Especifica 
                        la función de espacio del usuario para agregar al servidor.</para></listitem>
                <listitem><para><code>setClass($class)</code>: Especifica una 
                        clase u objeto para agregar al servidor; todos los métodos 
                        públicos de ese item serán expuestos como métodos JSON-RPC.</para></listitem>
                <listitem><para><code>fault($fault = null, $code = 404, $data =
                        null)</code>: Crea y devuelve un objeto 
                        <classname>Zend_Json_Server_Error</classname>.</para></listitem>
                <listitem><para><code>handle($request = false)</code>: Maneja 
                        una solicitud JSON-RPC; opcionalmente, pasa un objeto 
                        <classname>Zend_Json_Server_Request</classname> a utlizar  
                        (crea uno por defecto).</para></listitem>
                <listitem><para><code>getFunctions()</code>: Devuelve una lista 
                        de todos los métodos agregados.</para></listitem>
                <listitem><para><code>setRequest(Zend_Json_Server_Request
                        $request)</code>: Especifica un objeto solicitud para el 
                        servidor a utilizar.</para></listitem>
                <listitem><para><code>getRequest()</code>: Recupera el objeto 
                        solicitud usado por el servidor.</para></listitem>
                <listitem><para><code>setResponse(Zend_Json_Server_Response
                        $response)</code>: Establece el objeto respuesta para el 
                        servidor a utilizar.</para></listitem>
                <listitem><para><code>getResponse()</code>: Recupera el objeto 
                        respuesta usado por el servidor.</para></listitem>
                <listitem><para><code>setAutoEmitResponse($flag)</code>:
                        Indica si el servidor debería emitir automáticamente la 
                        respuesta y todas las cabeceras; por defecto, esto es 
                        verdadero.</para></listitem>
                <listitem><para><code>autoEmitResponse()</code>: Determina si la 
                        auto-emisión de la respuesta está habilitada.</para></listitem>
                <listitem><para><code>getServiceMap()</code>: Recupera la 
                        descripción del mapa de servicio en el form de un 
                        objeto  
                        <classname>Zend_Json_Server_Smd</classname>.</para></listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.json.server.details.zendjsonserverrequest">
            <title>Zend_Json_Server_Request</title>

            <para>
                El medio ambiente de una solicitud JSON-RPC está encapsulado en 
                el objeto <classname>Zend_Json_Server_Request</classname>. 
                Este objeto le permite establecer porciones necesarias de la 
                solicitud JSON-RPC, incluida el ID de la solicitud, parámetros y 
                especificaciones de la versión JSON-RPC. Tiene la capacidad de 
                cargarse a sí mismo via JSON o un conjunto de opciones, y puede 
                mostrase a si mismo como JSON vía el método <code>toJson()</code>.
            </para>

            <para>
                El objeto solicitud tiene los siguientes métodos disponibles:
            </para>

            <itemizedlist>
                <listitem><para><code>setOptions(array $options)</code>: Especifica 
                        la configuración del objeto. <code>$options</code> puede 
                        contener claves que concuerden con cualuier método 'set':
                        <code>setParams()</code>, <code>setMethod()</code>,
                        <code>setId()</code>, y
                        <code>setVersion()</code>.</para></listitem>
                <listitem><para><code>addParam($value, $key = null)</code>: 
                        Agrega un parámetro para usar con el método de llamada. 
                        Los parámetros pueden ser sólo los valores, o pueden 
                        incluir opcionalmente el nombre del parámetro.
                        </para></listitem>
                <listitem><para><code>addParams(array $params)</code>: Agrega 
                        múltiples parámetros a la vez; proxies a
                        <code>addParam()</code></para></listitem>
                <listitem><para><code>setParams(array $params)</code>: 
                        Establece todos los parámetros a la vez; sobrescribe 
                        cualquiera de los parámetros existentes.</para></listitem>
                <listitem><para><code>getParam($index)</code>: Recupera un 
                        parámetro por posición o por el nombre.</para></listitem>
                <listitem><para><code>getParams()</code>: Recupera todos los 
                        parámetros a la vez.</para></listitem>
                <listitem><para><code>setMethod($name)</code>: Establece el 
                        método para llamar.</para></listitem>
                <listitem><para><code>getMethod()</code>: Recupera el método que 
                        será llamado.</para></listitem>
                <listitem><para><code>isMethodError()</code>: Determinar si la 
                        solicitud está malformada o no y si daría como resultado 
                        un error.</para></listitem>
                <listitem><para><code>setId($name)</code>: Establecer el 
                        identificador de solicitud(utilizado por el cliente 
                        para igualar las solicitudes de respuestas).</para></listitem>
                <listitem><para><code>getId()</code>: Recuperar el identificador 
                        de solicitudes.</para></listitem>
                <listitem><para><code>setVersion($version)</code>: Establecer la 
                        versión de la especificación JSON-RPC que conforma la 
                        solicitud. Puede ser '1.0' o '2.0'.</para></listitem>
                <listitem><para><code>getVersion()</code>: Recuperar la versión 
                        de la especificación JSON-RPC utilizados por la solicitud.
                        </para></listitem>
                <listitem><para><code>loadJson($json)</code>: Cargar el objeto 
                        solicitud de una cadena JSON.</para></listitem>
                <listitem><para><code>toJson()</code>: Mostrar la solicitud como 
                        un string JSON.</para></listitem>
            </itemizedlist>

            <para>
                Una versión específica de HTTP está disponible a través de
                <classname>Zend_Json_Server_Request_Http</classname>. Esta clase 
                podrá recuperar la solicitud via <code>php://input</code>, y 
                permite el acceso JSON sin procesar vía el método 
                <code>getRawJson()</code>. 
            </para>
        </sect3>

        <sect3 id="zend.json.server.details.zendjsonserverresponse">
            <title>Zend_Json_Server_Response</title>

            <para>
                La respuesta del conjunto de datos JSON-RPC es encapsulada en el 
                objeto <classname>Zend_Json_Server_Response</classname>. 
                Este objeto le permite ajustar el valor de retorno de la 
                solicitud, siendo la respuesta un error o no, el identificador 
                de solicitud, con que versión de especificación esta conformada 
                la respuesta de JSON-RPC, y, opcionalmente el mapa de servicio.
            </para>

            <para>
                El objeto respuesta tiene los siguientes métodos disponibles:
            </para>

            <itemizedlist>
                <listitem><para><code>setResult($value)</code>: Establecer el 
                        resultado de la respuesta.</para></listitem>
                <listitem><para><code>getResult()</code>: Recuperar el resultado 
                        de la respuesta.</para></listitem>
                <listitem><para><code>setError(Zend_Json_Server_Error
                    $error)</code>: Establecer un objeto error. Si ya está, este 
                    será utilizado como la respuesta cuando se serialize a JSON.
                    </para></listitem>
                <listitem><para><code>getError()</code>: Recuperar el objeto 
                    error, si lo hubiera.</para></listitem>
                <listitem><para><code>isError()</code>: Si la respuesta es una 
                        respuesta de error o no.</para></listitem>
                <listitem><para><code>setId($name)</code>: Establecer el 
                        identificador de solicitud (de manera que la respuesta 
                        del cliente pueda coincidir con la solicitud original).
                        </para></listitem>
                <listitem><para><code>getId()</code>: Recuperar el identificador 
                        de solicitud.</para></listitem>
                <listitem><para><code>setVersion($version)</code>: Establecer la 
                        versión JSON-RPC con la que deba estar conformada la 
                        respuesta.</para></listitem>
                <listitem><para><code>getVersion()</code>: Recuperar la versión 
                        JSON-RPC con la cumple la respuesta.</para></listitem>
                <listitem><para><code>toJson()</code>: Serializar la respuesta a 
                        JSON. Si la respuesta es una respuesta de error, 
                        serializar el objeto error.</para></listitem>
                <listitem><para><code>setServiceMap($serviceMap)</code>: 
                        Establecer el objeto mapa de servicio para la respuesta.
                        </para></listitem>
                <listitem><para><code>getServiceMap()</code>: Recuperar el objeto 
                        mapa de servicio, si hubiera alguno.</para></listitem>
            </itemizedlist>

            <para>
                Una versión específica de HTTP está disponible a través de 
                <classname>Zend_Json_Server_Response_Http</classname>. Esta clase 
                enviará las cabeceras HTTP apropiadas así como serializará la 
                respuesta como JSON.
            </para>
        </sect3>

        <sect3 id="zend.json.server.details.zendjsonservererror">
            <title>Zend_Json_Server_Error</title>

            <para>
                JSON-RPC tiene un formato especial para informar condiciones de 
                error. Todos los errores necesitan proporcionar, mínimamente, 
                un mensaje de error y un código de error; opcionalmente, pueden 
                proporcionar datos adicionales, tales como un backtrace.
            </para>

            <para>
                Los códigos de error derivan de los recomendados por <ulink
                    url="http://xmlrpc-epi.sourceforge.net/specs/rfc.fault_codes.php">el 
                    proyecto XML-RPC EPI</ulink>. <classname>Zend_Json_Server</classname>
                apropiadamente asigna el código sobre la base de la condición de 
                error. Para las excepciones de la aplicación, se utiliza el 
                código '-32000'.
            </para>

            <para>
                <classname>Zend_Json_Server_Error</classname> expone los 
                siguientes métodos:
            </para>

            <itemizedlist>
                <listitem><para><code>setCode($code)</code>: Establece el código 
                    de error; si el código de error no está en el rango de 
                    aceptación de XML-RPC, -32000 será asignado.</para></listitem>
                <listitem><para><code>getCode()</code>: Recuperar el actual 
                    código de error.</para></listitem>
                <listitem><para><code>setMessage($message)</code>: Establecer el 
                    mensaje de error.</para></listitem>
                <listitem><para><code>getMessage()</code>: Recuperar el mensaje 
                    de error actual.</para></listitem>
                <listitem><para><code>setData($data)</code>: Establecer el conjunto 
                    de datos auxiliares para calificar más adelante el error, 
                    tal como un backtrace.</para></listitem>
                <listitem><para><code>getData()</code>: Recuperar cualquier 
                    auxiliar actual de errores de datos.</para></listitem>
                <listitem><para><code>toArray()</code>: Mandar el error a un 
                    array. El array contendrá las claves 'code', 'message', 
                    y 'data'.</para></listitem>
                <listitem><para><code>toJson()</code>: Mandar el error a una 
                    representación de error JSON-RPC.</para></listitem>
            </itemizedlist>
        </sect3>

        <sect3 id="zend.json.server.details.zendjsonserversmd">
            <title>Zend_Json_Server_Smd</title>

            <para>
                SMD quiere decir Service Mapping Description, un esquema JSON que 
                define cómo un cliente puede interactuar con un servicio web en 
                particular. En el momento de escribir esto, la <ulink
                    url="http://groups.google.com/group/json-schema/web/service-mapping-description-proposal">especificación</ulink>
                todavía no ha sido ratificada oficialmente, pero ya está en uso  
                en Dojo toolkit así como en otros clientes consumidores de 
                JSON-RPC.
            </para>

            <para>
                En su aspecto más básico, un SMD indica el método de transporte 
                (POST, GET, TCP/IP, etc), el tipo de envoltura de la solicitud  
                (generalmente se basa en el protocolo del servidor), 
                el objetivo URL del proveedor del servicio, y un mapa de los 
                servicios disponibles. En el caso de JSON-RPC, el servicio de mapa 
                es una lista de los métodos disponibles, en el que cada método 
                documenta los parámetros disponibles y sus tipos, así como los 
                tipos de valores esperados a devolver.
            </para>

            <para>
                <classname>Zend_Json_Server_Smd</classname> Proporciona un objeto 
                orientado para construir servicios de mapas. 
                Básicamente, pasa los metadatos describiendo el servicio usando 
                mutators, y especifica los servicios (métodos y funciones).
            </para>

            <para>
                Las descripciones de los servicios son típicamente instancias de 
                <classname>Zend_Json_Server_Smd_Service</classname>; también 
                puede pasar toda la información como un array a los diversos 
                mutators de servicios en <classname>Zend_Json_Server_Smd</classname>, 
                y que instanciará on objeto de servicio por usted. 
                Los objetos de servicio contienen información como el nombre del 
                servicio (típicamente, la función o el nombre del método), los 
                parámetros (nombres, tipos y posición), y el tipo del valor de 
                retorno. Opcionalmente, cada servicio puede tener su propio 
                objetivo y envoltura, aunque esta funcionalidad rara vez es utilizada.
            </para>

            <para>
                <classname>Zend_Json_Server</classname> Realmente todo esto 
                sucede entre bambalinas para usted, utilizando reflexión sobre 
                las clases y funciones agregadas; debe crear su propio servicio 
                de mapas sólo si necesita brindar funcionalidad personalizada que 
                la introspección de clase y función no puede ofrecer.
            </para>

            <para>
                Los métodos disponibles en <classname>Zend_Json_Server_Smd</classname> incluyen:
            </para>

            <itemizedlist>
                <listitem><para><code>setOptions(array $options)</code>: Establecer 
                        un objeto SMD desde un array de opciones. Todos los 
                        mutators (métodos comenzando con 'set') se pueden usar 
                        como claves.</para></listitem>
                <listitem><para><code>setTransport($transport)</code>: Establecer 
                        el transporte usado para acceder al servicio; únicamente 
                        POST es actualmente soportado.</para></listitem>
                <listitem><para><code>getTransport()</code>: Obtener el servicio 
                        de transporte actual.</para></listitem>
                <listitem><para><code>setEnvelope($envelopeType)</code>: 
                        Establecer la envoltura de la solicitud que debería ser 
                        utilizada para acceder al servicio. Actualmente las  
                        constantes soportadas son 
                        <classname>Zend_Json_Server_Smd::ENV_JSONRPC_1</classname> y
                        <classname>Zend_Json_Server_Smd::ENV_JSONRPC_1</classname>.</para></listitem>
                <listitem><para><code>getEnvelope()</code>: Obtener la envoltura 
                        de la petición actual.</para></listitem>
                <listitem><para><code>setContentType($type)</code>: Establecer 
                        el tipo de contenido que deben utilizar las solicitudes 
                        (por defecto, es 'application/json»).</para></listitem>
                <listitem><para><code>getContentType()</code>: Conseguir el 
                        tipo del contenido actual para las solicitudes al 
                        servicio.</para></listitem>
                <listitem><para><code>setTarget($target)</code>: Establecer el 
                        punto final de la URL para el servicio.</para></listitem>
                <listitem><para><code>getTarget()</code>: Obtener el punto final 
                        de la URL para el servicio.</para></listitem>
                <listitem><para><code>setId($id)</code>: Normalmente, este es el 
                        punto final de la URL del servicio (igual que el 
                        objetivo).</para></listitem>
                <listitem><para><code>getId()</code>: Recuperar el ID del servicio 
                        (normalmente el punto final de la URL del servicio).
                        </para></listitem>
                <listitem><para><code>setDescription($description)</code>: 
                        Establecer una descripción del servicio (típicamente 
                        información narrativa que describe el propósito del 
                        servicio).</para></listitem>
                <listitem><para><code>getDescription()</code>: Obtener la 
                        descripción del servicio.</para></listitem>
                <listitem><para><code>setDojoCompatible($flag)</code>: 
                        Establecer un flag que indique si el SMD es compatible 
                        o no con el toolkit de Dojo. Cuando sea verdadero, el 
                        JSON SMD será formateado para cumplir con el formato que 
                        espera el cliente de Dojo JSON-RPC.</para></listitem>
                <listitem><para><code>isDojoCompatible()</code>: Devuelve el valor 
                        del flag de compatibilidad de Dojo (falso, por defecto).
                        </para></listitem>
                <listitem><para><code>addService($service)</code>: Añade un 
                        servicio al mapa. Puede ser un array de información a 
                        pasar al constructor de
                        <classname>Zend_Json_Server_Smd_Service</classname>, o 
                        una instancia de esa clase.</para></listitem>
                <listitem><para><code>addServices(array $services)</code>: 
                        Agrega múltiples servicios a la vez.</para></listitem>
                <listitem><para><code>setServices(array $services)</code>: 
                        Agrega múltiples servicios a la vez, sobreescribiendo 
                        cualquiera de los servicios previamente establecidos.
                        </para></listitem>
                <listitem><para><code>getService($name)</code>: Ontiene el servicio 
                        por su nombre.</para></listitem>
                <listitem><para><code>getServices()</code>: Obtener todos los 
                        servicios agregados.</para></listitem>
                <listitem><para><code>removeService($name)</code>: Elimina un 
                        servicio del mapa.</para></listitem>
                <listitem><para><code>toArray()</code>: Mandar el mapa de servicio 
                        a un array.</para></listitem>
                <listitem><para><code>toDojoArray()</code>: Mandar el mapa de servicio 
                        a un array compatible con Dojo Toolkit.</para></listitem>
                <listitem><para><code>toJson()</code>: Mandar el mapa de servicio 
                        a una representación JSON.</para></listitem> 
            </itemizedlist>

            <para>
                <classname>Zend_Json_Server_Smd_Service</classname> tiene los 
                        siguientes métodos:
            </para>

            <itemizedlist>
                <listitem><para><code>setOptions(array $options)</code>: 
                        Establecer el estado del objeto dede un array. Cualquier 
                        mutator (métodos comenzando con 'set') puede ser utilizado 
                        como una clave y establecerlo mediante este método.
                        </para></listitem>
                <listitem><para><code>setName($name)</code>: Establecer el nombre 
                        del servicio (típicamente, la función o el nombre del 
                        método).</para></listitem>
                <listitem><para><code>getName()</code>: Recuperar el nombre del 
                        servicio.</para></listitem>
                <listitem><para><code>setTransport($transport)</code>: Establecer 
                        el servicio de transporte (actualmente, sólo transportes 
                        apoyados por <classname>Zend_Json_Server_Smd</classname> 
                        son permitidos).</para></listitem>
                <listitem><para><code>getTransport()</code>: Recuperar el transporte 
                        actual.</para></listitem>
                <listitem><para><code>setTarget($target)</code>: Establecer el 
                        punto final de la URL del servicio (típicamente, este 
                        será el mismo que el SMD en general, al cual el servicio 
                        está agregado).</para></listitem>
                <listitem><para><code>getTarget()</code>: Obtener el punto final 
                        de la URL del servicio.</para></listitem>
                <listitem><para><code>setEnvelope($envelopeType)</code>: 
                        Establecer la envoltura del servicio (actualmente, sólo 
                        se permiten las envolturas soportadas por 
                        <classname>Zend_Json_Server_Smd</classname>.</para></listitem>
                <listitem><para><code>getEnvelope()</code>: Recuperar el tipo de 
                        envoltura del servicio.</para></listitem>
                <listitem><para><code>addParam($type, array $options = array(),
                            $order = null)</code>: Añadir un parámetro para el 
                        servicio. Por defecto, sólo el tipo de parámetro es necesario. 
                        Sin embargo, también puede especificar el orden, así como 
                        opciones tales como:</para>
                    <itemizedlist>
                        <listitem><para><emphasis>name</emphasis>: el nombre del 
                            parámetro</para></listitem>
                        <listitem><para><emphasis>optional</emphasis>: cuándo 
                            el parámetro es opcional o no</para></listitem>
                        <listitem><para><emphasis>default</emphasis>: un valor 
                            por defecto para el parámetro</para></listitem>
                        <listitem><para><emphasis>description</emphasis>: texto 
                            describiendo el parámetro</para></listitem>
                    </itemizedlist>
                </listitem>
                <listitem><para><code>addParams(array $params)</code>: Agregar 
                    varios parámetros a la vez; cada param debería ser un array 
                    asociativo conteniendo mínimamente la clave 'type' describiendo 
                    el tipo de parámetro y, opcionalmente la clave 'order'; 
                    cualquiera de las otras claves serán pasados como 
                    <code>$options</code> a <code>addOption()</code>.</para></listitem>
                <listitem><para><code>setParams(array $params)</code>: 
                    Establecer muchos parámetros a la vez, sobrescribiendo 
                    cualquiera de los parámetros existentes.</para></listitem>
                <listitem><para><code>getParams()</code>: Recuperar todos los 
                    parámetros actualmente establecidos.</para></listitem>
                <listitem><para><code>setReturn($type)</code>: Establecer el tipo 
                    del valor de retorno del servicio.</para></listitem>
                <listitem><para><code>getReturn()</code>: Obtener el tipo del 
                    valor de retorno del servicio.</para></listitem>
                <listitem><para><code>toArray()</code>: Mandar el servicio a un 
                    array.</para></listitem>
                <listitem><para><code>toJson()</code>: Mandar el servicio a una 
                    representación JSON.</para></listitem>
            </itemizedlist>
        </sect3>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
