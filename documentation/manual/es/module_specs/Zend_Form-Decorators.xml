<sect1 id="zend.form.decorators">
    <title>Creando un personalizado marcado de formulario usando Zend_Form_Decorator</title>

    <para>
        Representando un objeto form es completamente opcional -- usted no necesita usar
        los metodos <code>Zend_Form</code> render() en absoluto. Sin embargo, si lo hace,
        los decoradores son usados para representar varios objetos form.
    </para>

    <para>
        Un arbitrario numero de decoradores pueden estar junto a cada elemento
        (elements, display groups, sub forms o el objeto form por si mismo);
        Sin embargo, solo un decorador de un tipo dado puede estar al lado de cada 
        elemento. Los decoradores son llamados en el orden en que han sido introducidos. Dependiendo
        del decorador, se puede reemplazar el contenido que se ha pasado o adjunto o 
        pre enviado. 
    </para>

    <para>
        El estado del objeto es determinado via las opciones de configuracion pasadas al constructor
        o el metodo decorador <code>setOptions()</code>. Cuando se crean 
        decoradores mediante funciones <code>addDecorator()</code> o metodos relacionados,
        las opciones pueden ser pasadas como argumentos al metodo. Esto puese ser usado para
        una especifica ubicacion, un separador se usa entre el contenido pasado y el
        nuevo contenido generado y cualquier opcion que el decorador soporte.
    </para>

    <para>
        Antes que cada metodo decorador <code>render()</code> es llamado, el
        actual item es determinado en el decorador usando <code>setElement()</code>,
        dando al decorador conocimiento del item representado. Esto permite
        crear decoradores que solo representan especificas porciones del item
        -- tal como etiquetas, el valor, mensajes de error, etc. Encadenando
        muchos decoradores que representan especificos segmentos, usted 
        puede construir complejos marcados representando al item entero.
    </para>

    <sect2 id="zend.form.decorators.operation">
        <title>Operacion</title>

        <para>
            Para configurar un decorador, pasar una matriz de opciones o un
            objeto <code>Zend_Config</code> a este constructor, a una matriz
            <code>setOptions()</code>, o a un objeto <code>Zend_Config</code>
            <code>setConfig()</code>.
        </para>

        <para>
            Opciones standarizadas incluyen:
        </para>

        <itemizedlist>
            <listitem><para>
                    <code>placement</code>: La ubicacion puede ser cualquiera de los dos 'append' o
                    'prepend' (caso insensitivo) e indica cualquier contenido
                    pasado a <code>render()</code> sera adjuntado o 
                    antepuesto respectivamente. En el caso de que el decorador
                    reemplace el contenido, esta configuracion es ignorada. La configuracion
                    por defecto es adjuntada.
            </para></listitem>

            <listitem><para>
                    <code>separator</code>: El separator es usado entre el 
                    contenido pasado a <code>render()</code> y el nuevo contenido
                    generado por el decorador, o entre items generados por el
                    decorador (ejemplo FormElements usa el separador entre cada
                    item generado). En el caso que un decorador reemplace el
                    contenido, esta configuracion puede ser ignorada. El valor por defecto
                    es <code>PHP_EOL</code>.
            </para></listitem>
        </itemizedlist>

        <para>
            La interface del decorador especifica los metodos para interactuar con las 
            opciones. Esto incluye:
        </para>

        <itemizedlist>
            <listitem><para>
                    <code>setOption($key, $value)</code>: determina una sola opcion.
            </para></listitem>

            <listitem><para>
                    <code>getOption($key)</code>: recuperar un solo valor de opcion.
            </para></listitem>

            <listitem><para>
                    <code>getOptions()</code>: recuperar todas las opciones.
            </para></listitem>

            <listitem><para>
                    <code>removeOption($key)</code>: remover o eliminar una sola opcion.
            </para></listitem>

            <listitem><para>
                    <code>clearOptions()</code>: remover o eliminar todas las opciones.
            </para></listitem>
        </itemizedlist>

        <para>
            Decoradores son disenados para interactuar con varios
            tipos de clases <code>Zend_Form</code>: <code>Zend_Form</code>,
            <code>Zend_Form_Element</code>, <code>Zend_Form_DisplayGroup</code>,
            y todas las clases derivan de ellas. El metodo
            <code>setElement()</code> permite determinar el objeto del 
            decorador que esta actualmente trabajando con, y <code>getElement()</code>
            es usado para recuperarlo.
        </para>

        <para>
            Cada metodo decorador <code>render()</code> acepta una cadena
            <code>$content</code>. Cuando el primer decorador es llamado, esta
            cadena esta tipicamente vacia, mientras las subsecuentes llamadas seran
            puestas. Basados en el tipo de decorador y en las opciones pasadas,
            el decorador ya sea reemplazara la cadena, antenpodra la cadena
            o adjuntara la cadena; una separador opcional sera usado en las
            dos ultimas situaciones.
        </para>
    </sect2>

    <sect2 id="zend.form.decorators.standard">
        <title>Decoradores estandar</title>

        <para>
            <code>Zend_Form</code> entrega muchos decoradores estandar; ver
            <link linkend="zend.form.standardDecorators">el capitulo Decoradores 
            estandar</link> para detalles.
        </para>
    </sect2>

    <sect2 id="zend.form.decorators.custom">
        <title>Decoradores personalizados</title>

        <para>
            Si usted encuentra que sus necesidades son complejas o necesita una enorme
            personalizacion, usted deberia considerar crear un personalizado decorador.
        </para>

        <para>
            Decoradores necesitan solo implementar
            <code>Zend_Decorator_Interface</code>. La interface especifica lo
            siguiente:
        </para>

        <programlisting role="php"><![CDATA[
interface Zend_Decorator_Interface
{
    public function __construct($options = null);
    public function setElement($element);
    public function getElement();
    public function setOptions(array $options);
    public function setConfig(Zend_Config $config);
    public function setOption($key, $value);
    public function getOption($key);
    public function getOptions();
    public function removeOption($key);
    public function clearOptions();
    public function render($content);
}
]]>
        </programlisting>

        <para>
            Para hacerlo mas simple, usted puede simplemente extender
            <code>Zend_Decorator_Abstract</code>, el cual implementa todos los metodos
            excepto <code>render()</code>.
        </para>

        <para>
            Como ejemplo, vamos a decir quue usted quiere reducir el numero de
            decoradores que utiliza, y construir un "compuesto" decorador que cuido
            la etiqueta generadora, elemento, algun mensaje de error, y describir 
            en HTML <code>div</code>. Usted puede construir como un 'Compuesto'
            decorador como sigue:
        </para>

        <programlisting role="php"><![CDATA[
class My_Decorator_Composite extends Zend_Form_Decorator_Abstract
{
    public function buildLabel()
    {
        $element = $this->getElement();
        $label = $element->getLabel();
        if ($translator = $element->getTranslator()) {
            $label = $translator->translate($label);
        }
        if ($element->isRequired()) {
            $label .= '*';
        }
        $label .= ':';
        return $element->getView()
                       ->formLabel($element->getName(), $label);
    }

    public function buildInput()
    {
        $element = $this->getElement();
        $helper  = $element->helper;
        return $element->getView()->$helper(
            $element->getName(),
            $element->getValue(),
            $element->getAttribs(),
            $element->options
        );
    }

    public function buildErrors()
    {
        $element  = $this->getElement();
        $messages = $element->getMessages();
        if (empty($messages)) {
            return '';
        }
        return '<div class="errors">' .
               $element->getView()->formErrors($messages) . '</div>';
    }

    public function buildDescription()
    {
        $element = $this->getElement();
        $desc    = $element->getDescription();
        if (empty($desc)) {
            return '';
        }
        return '<div class="description">' . $desc . '</div>';
    }

    public function render($content)
    {
        $element = $this->getElement();
        if (!$element instanceof Zend_Form_Element) {
            return $content;
        }
        if (null === $element->getView()) {
            return $content;
        }

        $separator = $this->getSeparator();
        $placement = $this->getPlacement();
        $label     = $this->buildLabel();
        $input     = $this->buildInput();
        $errors    = $this->buildErrors();
        $desc      = $this->buildDescription();

        $output = '<div class="form element">'
                . $label
                . $input
                . $errors
                . $desc
                . '</div>'

        switch ($placement) {
            case (self::PREPEND):
                return $output . $separator . $content;
            case (self::APPEND):
            default:
                return $content . $separator . $output;
        }
    }
}
]]>
        </programlisting>

        <para>
            Usted puede entonces ubicarlo en el directorio decorador:
        </para>

        <programlisting role="php"><![CDATA[
// para un elemento:
$element->addPrefixPath('My_Decorator',
                        'My/Decorator/',
                        'decorator');

// para todos los elementos:
$form->addElementPrefixPath('My_Decorator',
                            'My/Decorator/',
                            'decorator');
]]>
        </programlisting>

        <para>
            Usted puede especificar este decorador como 'Compuesto' y adjuntarlo a 
            un elemento:
        </para>

        <programlisting role="php"><![CDATA[
// Overwrite existing decorators with this single one:
$element->setDecorators(array('Composite'));
]]>
        </programlisting>

        <para>
            Mientras este ejemplo mostro como crear un decorador que genera
            salidas complejas de muchas propiedades de elementos, usted puede tambien crear
            decoradores que manejen un solo aspecto de un elemento; los decoradores
            'Decorador' y 'etiqueta' son excelentes ejemplos para 
            esta practica. Hacerlo le permite mezclar y combinar decoradores para llegar
            a complejas salidas -- y tambien anular aspectos de decoracion para 
            personalizar sus necesidades.
        </para>

        <para>
            Por ejemplo, si usted quiere simplemente desplegar que un error a ocurrido
            cuando validabamos un elemento, pero no desplegar individualmente 
            cada uno de los mensajes de error, usted podria crear su propio 
            decorador 'Errores':
        </para>

        <programlisting role="php"><![CDATA[
class My_Decorator_Errors
{
    public function render($content = '')
    {
        $output = '<div class="errors">The value you provided was invalid;
            please try again</div>';

        $placement = $this->getPlacement();
        $separator = $this->getSeparator();

        switch ($placement) {
            case 'PREPEND':
                return $output . $separator . $content;
            case 'APPEND':
            default:
                return $content . $separator . $output;
        }
    }
}
]]>
        </programlisting>

        <para>
            En este ejemplo particular, debido al segmento del decorador final,
            'Errors', se combina como <code>Zend_Form_Decorator_Errors</code>,
            sera generado <emphasis>en lugar de</emphasis> el decorador
            -- significa que usted no necesitara cambiar ningun decorador para modificar la
            salida. Nombrando sus decoradores despues de los existentes decoradores 
            estandar, usted puede modificar decoradores sin necesitad de modificar sus
            elementos decoradores.
        </para>
    </sect2>

    <sect2 id="zend.form.decorators.individual">
        <title>Generando individuales decoradores</title>

        <para>
            Desde que los decoradores pueden capturar distintos metadatos del elemento o formulario
            que ellos decoran, es a menudo util generar un decorador individual
            Afortunadamente, esta caracteristica es posible inicializando el metodo
            en cada tipo de clase form (forms, sub form, display group,
            element).
        </para>

        <para>
            Para hacer eso, simplemente <code>render[DecoratorName]()</code>, cuando
            "[DecoratorName]" es el "nombre corto" de su decorador; opcionalmente,
            usted puede pasar en el contenido lo que usted quiera. Por ejemplo:
        </para>

        <programlisting role="php"><![CDATA[
// genera el elemento decorador label:
echo $element->renderLabel();

// genera solo el campo display group, con algun contenido:
echo $group->renderFieldset('fieldset content');

// genera solo el formulario HTML, con algun contenido:
echo $form->renderHtmlTag('wrap this content');
]]></programlisting>

        <para>
            Si el decorador no existe, una excepcion es inicializada.
        </para>

        <para>
            Esto puede ser util particularmente cuando se genera un formulario con el
            decorador ViewScript; cada elemento puede usar sus decoradores adjuntos
            para generar contenido, pero con concreto control.
        </para>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
